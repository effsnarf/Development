

var __assign = (this && this.__assign) || function () { __assign = Object.assign || function(t) { for (var s, i = 1, n = arguments.length; i < n; i++) { s = arguments[i]; for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p]; } return t; }; return __assign.apply(this, arguments); }; var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) { function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); } return new (P || (P = Promise))(function (resolve, reject) { function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } } function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } } function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); } step((generator = generator.apply(thisArg, _arguments || [])).next()); }); }; var __generator = (this && this.__generator) || function (thisArg, body) { var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g; return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g; function verb(n) { return function (v) { return step([n, v]); }; } function step(op) { if (f) throw new TypeError("Generator is already executing."); while (g && (g = 0, op[0] && (_ = 0)), _) try { if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t; if (y = 0, t) op = [op[0] & 2, t.value]; switch (op[0]) { case 0: case 1: t = op; break; case 4: _.label++; return { value: op[1], done: false }; case 5: _.label++; y = op[1]; op = [0]; continue; case 7: op = _.ops.pop(); _.trys.pop(); continue; default: if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; } if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; } if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; } if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; } if (t[2]) _.ops.pop(); _.trys.pop(); continue; } op = body.call(thisArg, _); } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; } if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true }; } }; var __read = (this && this.__read) || function (o, n) { var m = typeof Symbol === "function" && o[Symbol.iterator]; if (!m) return o; var i = m.call(o), r, ar = [], e; try { while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value); } catch (error) { e = { error: error }; } finally { try { if (r && !r.done && (m = i["return"])) m.call(i); } finally { if (e) throw e.error; } } return ar; }; var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) { if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) { if (ar || !(i in from)) { if (!ar) ar = Array.prototype.slice.call(from, 0, i); ar[i] = from[i]; } } return to.concat(ar || Array.prototype.slice.call(from)); }; var __values = (this && this.__values) || function(o) { var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0; if (m) return m.call(o); if (o && typeof o.length === "number") return { next: function () { if (o && i >= o.length) o = void 0; return { value: o && o[i++], done: !o }; } }; throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined."); };

// Takes this:
// [{"name":"ChatOpenAI","methods":[{"name":"constructor","args":["role","log"]},{"name":"send","args":["message"]},{"name":"sendSeveral","args":["messages"]},{"name":"deleteLastMessage","args":[]}]}]
// And returns a JavaScript class
// with each method calling await this._apiCall("ChatOpenAI", "send", [message])

var ApifyClient = /** @class */ (function () { function ApifyClient() { } ApifyClient.createClass = function (baseUrl, signature) { var e_1, _a; var _apiCall = function (method, args) { if (args === void 0) { args = []; } return __awaiter(this, void 0, void 0, function () { var url, argsMap, requestBody, response, json; return __generator(this, function (_a) { switch (_a.label) { case 0:
    // Check if a new instance needs to be created
    if (method !== 'new' && !this._.id) { throw new Error("Use (await ".concat(this._.name, ".new()) to create a new instance.")); } url = "".concat(this._.baseUrl, "/").concat(this._.name); if (this._.id) { url += "/".concat(this._.id); } url += "/".concat(method); argsMap = this._getArgsMap(method, args); requestBody = {}; argsMap.forEach(function (value, key) { return requestBody[key] = value; }); return [4 /*yield*/, fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(requestBody) })]; case 1: response = _a.sent(); return [4 /*yield*/, response.json()]; case 2: json = _a.sent();
    
    
    // Throw an error if the response contains an error message
    if (json.error) { throw new Error(json.error); }
    // Return the result from the API call
    return [2 /*return*/, json.result]; } }); }); }; var _getArgsMap = function (method, args) { var argsMap = new Map(); for (var i = 0; i < args.length; i++) { var meth = signature.methods.find(function (m) { return m.name == method; }); if (!meth) throw new Error("Method ".concat(method, " not found")); argsMap.set(meth.args[i], args[i]); } return argsMap; }; var cls = /** @class */ (function () { function class_1() { } class_1.new = function () { return __awaiter(this, void 0, void 0, function () { var inst, _a; return __generator(this, function (_b) { switch (_b.label) { case 0: inst = new cls(); _a = inst._; return [4 /*yield*/, inst._apiCall("new")]; case 1: _a.id = (_b.sent()).id; return [2 /*return*/, inst]; } }); }); }; class_1.prototype._apiCall = function () { var args = []; for (var _i = 0; _i < arguments.length; _i++) { args[_i] = arguments[_i]; } return _apiCall.bind(this).apply(void 0, __spreadArray([], __read(args), false)); }; class_1.prototype._getArgsMap = function () { var args = []; for (var _i = 0; _i < arguments.length; _i++) { args[_i] = arguments[_i]; } return _getArgsMap.bind(this).apply(void 0, __spreadArray([], __read(args), false)); }; return class_1; }()); cls.prototype._ = __assign(__assign({}, signature), { baseUrl: baseUrl }); var _loop_1 = function (method) {
        // @ts-ignore
        cls.prototype[method.name] = function () { var args = []; for (var _i = 0; _i < arguments.length; _i++) { args[_i] = arguments[_i]; } return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) { switch (_a.label) { case 0: return [4 /*yield*/, this._apiCall(method.name, args)]; case 1: return [2 /*return*/, _a.sent()]; } }); }); }; }; try { for (var _b = __values(signature.methods), _c = _b.next(); !_c.done; _c = _b.next()) { var method = _c.value; _loop_1(method); } } catch (e_1_1) { e_1 = { error: e_1_1 }; } finally { try { if (_c && !_c.done && (_a = _b.return)) _a.call(_b); } finally { if (e_1) throw e_1.error; } } return cls; };
        // "http://localhost:3021/api" gets replaced when transpiling in Server.ts
        ApifyClient.createClasses = function (apiUrl) { if (apiUrl === void 0) { apiUrl = "/api"; } return __awaiter(this, void 0, void 0, function () { var classSigs, classes; return __generator(this, function (_a) { switch (_a.label) { case 0:
        // Make sure the URL doesn't end with a slash
        if (apiUrl.endsWith("/")) apiUrl = apiUrl.substring(0, apiUrl.length - 1); return [4 /*yield*/, fetch(apiUrl)]; case 1: return [4 /*yield*/, (_a.sent()).json()]; case 2: classSigs = (_a.sent()); classes = {};
        // Create a class for each signature
        classSigs.forEach(function (sig) { classes[sig.name] = ApifyClient.createClass(apiUrl, sig); });
        // Return the classes
        return [2 /*return*/, classes]; } }); }); }; return ApifyClient; }());
