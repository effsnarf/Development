{
  props: {
    {{#each props}}
    {{@key}}: {
      default: {{{or this null}}}
    },
    {{/each}}
  },
  data: function () {
    return {
        {{#each data}}
        {{@key}}: {{{or this null}}},
        {{/each}}
        _: {
          comp: {
            name: `{{unkebabize name}}`,
          },
          state: StateTracker.new(this._uid, "{{name}}", this.$root.client),
        }
    }
  },
  mounted: {{{addCode mounted "this._log_method('mounted', arguments); this.$root.onVueMounted(this); this.$emit = this._getNewEmit(this.$emit);"}}},
  unmounted: {{{addCode unmounted "this._log_method('unmounted', arguments); this.$root.onVueUnmounted(this);"}}},
  methods: {
    {{#each methods}}
    {{@key}}: {{{addMethodCode @key this}}},
    {{/each}}
    _getNewEmit: function (emit) {
      return function (event, ...args) {
        this._log_emit(event, args);
        emit.call(this, event, ...args);
      }
    },

    _log_emit: function(event, args) {
      this.$data._.state.log('e', event, args);
    },

    _log_method: function (methodName, args) {
      if (!this.$data._.state.isTrackingMethods) return;

      if ([`processQueue`, `recalc`, `getFontSize`,
        `onMouseMove`, `onMouseUp`,
        `preventDefaults`,
        `highlight`, `unhighlight`,
        `getCssClass`, `getTabClass`, `getLayerClass`, `getLayerType`
        ].includes(methodName)) return;
      if ([`draw`].some(s => methodName.includes(s))) return;

      this.$data._.state.log('m', methodName);

      return;

      console.log(
        `ðŸ§Š %c{{name}} %c${methodName} %o`,
        'color: green;',
        'color: yellow;',
        args);
    },
    _log_state: function (type, key, newValue, oldValue) {
      if ([`queue`, `width`, `height`, `generators`, `items`].includes(key)) return;
      if (!newValue && !oldValue) return;
      this.$data._.state.log(type, key, newValue, oldValue);
      if (!oldValue)
      {
        if (false)
        {
          console.log(
            `ðŸ§Š %c${this._.comp.name} %c${key} %o`,
            'color: green;',
            'color: cyan;',
            newValue);
        }
      }
    },
  },
  computed: {
    {{#each computed}}
    {{#if get}}
    {{@key}}: {
      get: {{{get}}},
    },
    {{else}}
    {{@key}}: {{{this}}},
    {{/if}}
    {{/each}}
  },
  watch: {
    {{#each data}}
    {{@key}}: {
      handler: function (newValue, oldValue) {
        this._log_state('d', `{{@key}}`, newValue, oldValue);
      },
      immediate: true,
    },
    {{/each}}
    
    {{#each props}}
    {{@key}}: {
      handler: function (newValue, oldValue) {
        this._log_state('p', `{{@key}}`, newValue, oldValue);
      },
      immediate: true,
    },
    {{/each}}

    {{#each watch}}
    {{#if handler}}
    {{@key}}: {
      handler: {{{handler}}},
      immediate: {{{or immediate false}}},
      deep: {{{or deep false}}},
    },
    {{else}}
    {{@key}}: {{{this}}},
    {{/if}}
    {{/each}}
  },
  template: `{{{dom dom name}}}`
}
