dom:
  div:
    .flex:
      .logo:
        img:
          class: logo
          src: https://i.imgur.com/bUbkhUu.png
        h1:
          ui.title:
            text: Vue Studio
    .user-account:
      component:
        ":is": userAccountCompName
    component:
      ":is": workspaceCompName
    .recent-vues:
      vs.recent.vues:
    div:
      ui.html.style:
        v-for: comp in allComps
        ":key": comp._id
        ":component": comp
props: null
data:
  comps:
    ide: []
    user: []
  css:
    library:
      shorthand: null
  timers:
    recompile:
      comp: {}
  userAccountCompName: null
  workspaceCompName: null
  stylesKey: 1
mounted: | #js
  function() {
    this.init();
  }
methods:
  init: | #js
    async function() {
      const ideVueApp = this;
      window.ideVueApp = ideVueApp;
      this.$root.with = util.with;
      this.$root.dbp = (await (DatabaseProxy.new("https://db.memegenerator.net/IDE")));
      this.$root.dbp.events.on("user.changed", this.onUserChanged.bind(this));
      this.$on("ide-comp-changed-2", this.onCompChanged2.bind(this));
      liveData.dbp = this.$root.dbp;
      this.initCssLibrary();
      await this.reload(true);
    }
  onUserChanged: | #js
    async function(user) {
      await this.reloadComps("user", true);
    }
  reload: | #js
    async function(ide = false) {
      if (ide) await this.reloadComps("ide");
      await this.reloadComps("user");
    }
  reloadComps: | #js
    async function(compType, clearCache = false) {
      const oldComps = [...this.comps[compType]];
      const oldCompIDs = oldComps.map(c => c._id);
      if (clearCache) this.clearCache(`vs.comps.${compType}`);
      const newComps = (await this.getFromCache(`vs.comps.${compType}`, () => this.loadVsComps(compType)));
      this.comps[compType].splice(0, this.comps[compType].length);
      this.comps[compType].push(...newComps);
      compDom.components.removeBy(c => oldCompIDs.includes(c._id));
      compDom.components.add(...newComps);
      await this.compileComps(compType, newComps);
      if (compType == "ide") {
        this.userAccountCompName = "ide-user-account-267";
        this.workspaceCompName = "ide-workspace-171";
      }
      await this.$nextTick();
      this.stylesKey++;
    }
  compileComp: | #js
    async function(comp) {
      const isIdeComp = (comp.name.kebabize().startsWith("ide-"));
      const vsGlobalsMixin = {
        data() {
          return {
            ideVueApp,
            compDom,
            viewDom,
            util
          };
        },
      };
      const performanceMixin = Mixins.CompEventTracker(this.logPerformanceCompEvent.bind(this));
      const activityLogMixin = this.getActivityLogMixin();
      const mixins = [];
      if (isIdeComp) mixins.push(vsGlobalsMixin);
      //mixins.push(performanceMixin);
      if (!isIdeComp) mixins.push(activityLogMixin);
      await vueUserComponentCompiler.compile(comp, { mixins });
    }
  compileComps: | #js
    async function(compType, comps) {
      if (!comps?.length) return;
      const showInfo = (compType != "ide");
      //if (showInfo) alertify.message(`Compiling ${comps.length} components...`);
      await Promise.all(comps.map(this.compileComp.bind(this)));
      //if (showInfo) alertify.message(`${comps.length} components compiled`);
      await liveData.unwatch.items(comps);
      comps.forEach(comp => liveData.watch.item("ComponentClasses", comp, { on: { changed: this.onCompChanged.bind(this) } }));
    }
  createNewComp: | #js
    async function () {
      var newComp = (await compDom.create.comp());
      this.comps.user.push(newComp);
      compDom.components.add(newComp);
      liveData.watch.item("ComponentClasses", newComp, { on: { changed: this.onCompChanged } });
      this.updateLocalCompCache(newComp);
    }
  getActivityLogMixin: | #js
    function() {
      const activityMixin = Mixins.CompEventTracker(this.logActivityCompEvent.bind(this));
      activityMixin.data = function() {
        return {
          _ide_activity: {
            items: []
          }
        };
      }
      return activityMixin;
    }
  logActivityCompEvent: | #js
    function(compEvent) {
      const vue = compEvent.context;
      const ideActivity = vue.$data._ide_activity;
      if (ideActivity.isPaused) return;
      const nextCompEventID = (ideActivity.nextCompEventID = (ideActivity.nextCompEventID || 0) + 1);
      if (!ideActivity.doneCompEventID) ideActivity.doneCompEventID = Vue.ref(0);
      const items = ideActivity.items;
      // If this is the first occurrence of this compEvent.name, mark it as [initial=true]
      const firstOccurrence = !items.find(ce => (ce.name == compEvent.name));
      if (firstOccurrence) {
        compEvent.initial = true;
      }
      if (ideActivity.doneCompEventID.value) {
        const doneIndex = (items.findIndex(ce => (ce._id == ideActivity.doneCompEventID.value)));
        if (doneIndex >= 0) items.splice((doneIndex + 1));
      }
      ideActivity.doneCompEventID.value = nextCompEventID;
      delete compEvent.context;
      const item = {
        _id: nextCompEventID,
        ...compEvent,
        icon: this.getOpIcon(compEvent.type),
        name: compEvent.name,
        elapsed: Math.round(compEvent.elapsed),
      }
      items.push(item);
      if (items.length > 100) items.shift();
    }
  getOpIcon: | #js
    function(type) {
      return ({
        "event": "‚ö°",
        "data": "üßä",
        "computed": "üí°",
        "watcher": "üëÅÔ∏è",
        "method": "üî¥",
      })[type] || "‚ùî";
    }
  logPerformanceCompEvent: | #js
    function(compEvent) {
      const perfInsp = this.getPerformanceInspector();
      if (!perfInsp) return;
      perfInsp.afterCompEvent(compEvent);
    }
  getPerformanceInspector: | #js
    function() {
      if (this._perfInsp) return this._perfInsp;
      if (!window.vueIdeApp) return null;
      this._perfInsp = vueIdeApp.vm.getDescendants(vueIdeApp, "ide.performance.inspector").first();
      return this._perfInsp;
    }
  initCssLibrary: | #js
    function() {
      function CssLibrary(url) {
        this.init = async function() {
          this.cssCode = (await (await fetch(url)).text());
          var classNameRegex = /^\.[a-z]([a-z0-9-]+)?(__([a-z0-9]+-?)+)?(--([a-z0-9]+-?)+){0,2}$/;
          this.classNames = {};
          this.classNames.all = css.parse(this.cssCode).stylesheet.rules
            .flatMap(r => r.selectors)
            .filter(s => s)
            .filter(s => s.startsWith(`.`))
            .filter(s => classNameRegex.test(s))
            .map(s => s.substr(1));
          this.classNames.all.sort();
        }
        this.init();
      }
      this.css.library.shorthand = (new CssLibrary("/static/shorthand.css"));
    }
  loadVsComps: | #js
    async function(compType) {
      let compTypeStr = compType;
      if (compType == "ide") compTypeStr = "Vue Studio";
      const msg = alertify.message(`‚è≥ Loading ${compTypeStr} components...`).delay(0);
      const comps = (await this.$root.dbp.componentClasses[compType].get());
      msg.dismiss();
      alertify.message(`${comps.length} components loaded`);
      return comps;
    }
  getIdeComp: | #js
    function(nameOrID) {
      return this.comps.ide.find(c => (c.name === nameOrID) || (c._id === nameOrID));
    }
  onCompChanged: | #js
    function(comp) {
      this.$emit("ide-comp-changed-2", comp);
    }
  onCompChanged2: | #js
    async function(comp) {
      var timers = this.timers.recompile.comp;
      clearTimeout(timers[comp._id]);
      timers[comp._id] = setTimeout(async () => {
        await this.updateLocalCompCache(comp);
        await this.recompileComp(comp);
      }, 1);
    }
  onCompRemoved: | #js
    function(comp) {
      compDom.components.removeBy((c => (c._id == comp._id)));
      this.comps.user.removeByField("_id", comp._id);
      this.updateLocalCompCacheItems("user");
    }
  updateLocalCompCache: | #js
    async function(comp) {
      // Update this.comps.ide / this.comps.user
      for (const compType of ["ide", "user"]) {
        const rtComp = this.comps[compType].find(c => (c._id === comp._id));
        if (!rtComp) continue;
        // Filter out [(() => comp)] properties
        const changes = (DeepDiff(rtComp, comp) || [])
          .filter(c => ((typeof c.lhs) != "function") && ((typeof c.rhs) != "function"));
        for (const change of changes) DeepDiff.applyChange(rtComp, null, change);
      }
      // Delete view from local cache
      const viewNodeKey = compDom.get.node.cache.key(comp, comp.view.node);
      localStorage.removeItem(viewNodeKey);
      // Update local cache
      let foundInCache = false;
      for (const compType of ["ide", "user"]) {
        if (this.comps[compType].find(c => (c._id === comp._id))) {
          await this.updateLocalCompCacheItems(compType);
          foundInCache = true;
        }
      }

      if (!foundInCache) {
        alertify.error(`Comp not found in local cache: ${comp.name}`);
      }
    }
  updateLocalCompCacheItems: | #js
    async function(compType) {
      this.setToCache(`vs.comps.${compType}`, this.comps[compType]);
    }
  recompileComp: | #js
    async function(comp) {
      // biztos ami biztos
      comp = compDom.get.comp.byID(comp._id);
      await this.compileComp(comp);
      this.$root.$emit("ide-comp-recompiled", comp);
      //alertify.message(`<h3>üì¶ ${comp.name}</h3><div>Component recompiled.</div>`);
    }
  onCompError: | #js
    function(vue, item, ex) {
      if (Array.isArray(item)) item = item.last();
      const icon = (item?.comp ? "üì¶" : item?.method ? "üî¥" : "‚ùî");
      const source = (!item) ? "‚ùî" : Object.values(item)[0].name;
      const message = (ex.message || ex);
      alertify.error(`<h3>${icon} ${source}</h3><div>${message}</div>`);
    }
  getFromCache: | #js
    async function(key, getValue) {
      const cachedItem = localStorage.getItem(key);
      if (!cachedItem) {
        const value = (await getValue());
        localStorage.setItem(key, JSON.stringify(value));
      }
      return JSON.parse(localStorage.getItem(key));
    }
  setToCache: | #js
    async function(key, value) {
      const started = Date.now();
      localStorage.setItem(key, JSON.stringify(value));
      const elapsed = (Date.now() - started);
    }
  clearCache: | #js
    async function(key) {
      localStorage.removeItem(key);
    }
computed:
  allComps: | #js
    function() {
      const comps = [];
      const ideCompIDs = this.comps.ide.map(c => c._id);
      const userComps = this.comps.user.filter(c => !ideCompIDs.includes(c._id));
      comps.push(...this.comps.ide);
      comps.push(...userComps);
      return comps;
    }
style:
  .recent-vues:
    position: fixed
    right: 2em
    top: 5em
  .logo:
    display: flex
    height: fit-content
    position: relative
    left: 0
  .logo h1:
    font-family: Audiowide
    font-size: 3em
    text-shadow: "-6px 6px 6px black"
    animation: slide-in-left 1s ease-out forwards
    animation-delay: 0.5s
    opacity: 0
  .logo img:
    width: 5em
    height: auto
    top: "-0.5em"
    margin-right: 1em
    animation: slide-in-up 1s ease-out forwards
    animation-delay: 0.2s
    opacity: 0
  .user-account:
    position: fixed
    right: 1em
    top: 1em
_:
  examples:
    count: 0
name: vs-app
template: >-
  <div class="comp-vs-app" path="-809055376."><div class="flex"
  path="-809055376.0"><div class="logo" path="-809055376.0.0"><img class="logo"
  src="https://i.imgur.com/bUbkhUu.png" path="-809055376.0.0.0"/><h1
  path="-809055376.0.0.1"><ui-title text="Vue Studio"
  path="-809055376.0.0.1.0"></ui-title></h1></div></div><div
  class="user-account" path="-809055376.1"><component :is="userAccountCompName"
  path="-809055376.1.0"></component></div><component :is="workspaceCompName"
  path="-809055376.2"></component></div>
