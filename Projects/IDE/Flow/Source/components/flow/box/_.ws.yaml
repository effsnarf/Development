dom:
  ui.window:
    ref: window1
    ':id': '''box.'' + box._id'
    class: show-on-hover-container
    @mouseenter: () => boxIsHovered = true
    @mouseleave: () => boxIsHovered = false
    @drag-stop: onDragStop
    v-model: box1.rect
    template: 
      v-slot: title
      .flex:
        h2:
          class: pointer-events-none
          v-text: getBoxIcon(box1)
        .span:
          ui.input.text.box:
            hint: '[name]'
            v-model: box1.data.name
            @input: '(value) => onBoxDataChange(box1, { name: value })'
            ':camouflage': true
    template: 
      v-slot: above
      .box-title:
        v-if: 'false'
        ':class': box.type
        .box-icon:
          v-text: getBoxIcon(box1)
        .box-name:
          v-text: box.data.name || ''
      ul: 
        li: 
          v-for: input in box1.sockets.inputs
          class: socket
          ':id': getSocketElementID(box1, input)
          ui.dnd.dropzone:
            @drop-item: (output) => onDropSocket(output, box1, input)
            ui.title: 
              icon: 🧊
              ':text': input.name
    template: 
      v-slot: content
      component:
        ':is': getBoxComponent(box1)
        ':box': box1
        ':box-is-hovered': boxIsHovered
    template: 
      v-slot: below
      .outputs:
        ul: 
          li: 
            v-for: (output, index) in box1.sockets.outputs
            class: socket
            ':id': getSocketElementID(box1, output)
            ui.dnd.draggable:
              ref: dragStartHint
              ':drag-item': getOutputSocketDragItem(box1, output)
              @drag-start: () => onDragStart(index)
              @drag-end: () => onDragEnd(index)
              @drag: onDrag
              ui.title: 
                icon: 🧊
                ':text': output.name
      .drag-end-hint:
        ref: dragEndHint
      ui.leader.line:
        v-if: isDraggingOutputSocket
        ':from-vue': dragStartHint
        ':to-vue': dragEndHint
        line-path: fluid
props:
  box: null
data:
  box1: null
  isDraggingOutputSocket: false
  dragStartHint: null
  dragEndHint: null
  boxIsHovered: false
mounted: | #js
  function() {
  }
methods:
  onBoxDataChange: | #js
    function(box, data) {
      this.$root.$emit("user.action", {
        redo: {
          method: "update.box.data",
          args: [box._id, data]
        }
      });
    }
  move: | #js
    async function(pos) {
      if (!this.$refs.window1) return;
      await this.$refs.window1.move(pos);
    }
  onDragStart: | #js
    function(index) {
      this.setDragHints(index);
      setTimeout(() => this.isDraggingOutputSocket = true, 100);
    }
  onDragEnd: | #js
    function() {
      this.dragEndHint = null;
      this.dragEndHint = null;
      this.isDraggingOutputSocket = false;
    }
  onDrag: | #js
    function(e) {
      if (!this.dragEndHint) return;
      this.dragEndHint.style.left = `${e.clientX}px`;
      this.dragEndHint.style.top = `${e.clientY}px`;
    }
  onDragStop: | #js
    async function() {
      if (this.$root.dragItem) return;
      this.$root.$emit("user.action", {
        redo: {
          method: "move.box",
          args: [this.box1._id, this.box1.rect.pos]
        }
      });
    }
  onDropSocket: | #js
    function(output, box, input) {
      this.$root.$emit("user.action", {
        redo: {
          method: "create.link",
          args: [output.box._id, output.socket._id, box._id, input._id]
        }
      });
    }
  getOutputSocketDragItem: | #js
    function(box, output) {
      return {
        box: {
          _id: box._id,
        },
        socket: output
      };
    }
  setDragHints: | #js
    function(index) {
      this.dragStartHint = () => this.$refs.dragStartHint[index];
      this.dragEndHint = this.$refs.dragEndHint;
    }
  getSocketElementID: | #js
    function(box, socket) {
      return `socket.${box._id}.${socket._id}`;
    }
  getBoxComponent: | #js
    function(box) {
      return `flow.box.${box.type}`.replace(/\./g, "-");
    }
  getBoxIcon: | #js
    function(box) {
      return {
        variable: `🧊${this.getDataTypeIcon(box.data.value)}`,
        function: '𝑓(𝑥)',
        "vue.comp": '📦',
      }[box.type] || '❔';
    }
  getDataTypeIcon: | #js
    function(value) {
      if (value === undefined) return '❔';
      if (value === null) return '⚪';
      if (typeof value === 'boolean') return value ? '✔️' : '❌';
      if (typeof value === 'number') return '🧩';
      if (typeof value === 'string') {
        const isUrl = value.match(/^http?:\/\//) || value.match(/^https?:\/\//);
        if (isUrl) return '🔗🆎';
        return '🆎';
      }
      if (typeof value === 'object') return '';
      return '❔';
    }
computed:
  alertify: | #js
    function() {
      return alertify;
    }
  jsyaml: | #js
    function() {
      return jsyaml;
    }
watch:
  box:
    handler: | #js
      async function(box) {
        this.box1 = Objects.clone(box);
        this.move(this.box1.rect.pos);
      }
    immediate: true
    deep: true
style:
  li.socket: null
  .comp-flow-box:
    z-index: 1000
  .box-title:
    font-size: 130%
    display: flex
    gap: 0.5em
    filter: drop-shadow(-3px 3px 2px black)
  .box-title.function .box-icon:
    color: '#B89B40'
  .show-on-hover-container > * > * > * > .show-on-hover, .show-on-hover-container > * > * > .show-on-hover:
    opacity: 0
    max-height: 0
    overflow: hidden
    transition: 1s
  .show-on-hover-container:hover > * > * > * > .show-on-hover, .show-on-hover-container:hover > * > * > .show-on-hover:
    opacity: 1
    max-height: 10em
    transition: 1s
  .drag-end-hint:
    position: fixed
    pointer-events: none
  .outputs:
    display: flex
    flex-direction: row-reverse
  .box:
    padding: 1em
    background: 'linear-gradient(to right, #303030, #101010)'
    cursor: move
  .pointer-events-none:
    pointer-events: none
_:
  examples:
    count: 0
name: flow-box
template: >-
  <ui-window class="comp-flow-box show-on-hover-container" ref="window1"
  :id="'box.' + box._id" @mouseenter="() =&gt; boxIsHovered = true"
  @mouseleave="() =&gt; boxIsHovered = false" @drag-stop="onDragStop"
  v-model="box1.rect" path="2028347659."><template v-slot:title
  path="2028347659.0"><div class="flex" path="2028347659.0.0"><h2
  class="pointer-events-none" v-text="getBoxIcon(box1)"
  path="2028347659.0.0.0"></h2><div class="span"
  path="2028347659.0.0.1"><ui-input-text-box hint="[name]"
  v-model="box1.data.name" @input="(value) =&gt; onBoxDataChange(box1, { name:
  value })" :camouflage="true"
  path="2028347659.0.0.1.0"></ui-input-text-box></div></div></template><template
  v-slot:above path="2028347659.1"><div class="box-title" v-if="false"
  :class="box.type" path="2028347659.1.0"><div class="box-icon"
  v-text="getBoxIcon(box1)" path="2028347659.1.0.0"></div><div class="box-name"
  v-text="box.data.name || ''" path="2028347659.1.0.1"></div></div><ul
  path="2028347659.1.1"><li class="socket" v-for="input in box1.sockets.inputs"
  :id="getSocketElementID(box1, input)" path="2028347659.1.1.0"><ui-dnd-dropzone
  @drop-item="(output) =&gt; onDropSocket(output, box1, input)"
  path="2028347659.1.1.0.0"><ui-title icon="🧊" :text="input.name"
  path="2028347659.1.1.0.0.0"></ui-title></ui-dnd-dropzone></li></ul></template><template
  v-slot:content path="2028347659.2"><component :is="getBoxComponent(box1)"
  :box="box1" :box-is-hovered="boxIsHovered"
  path="2028347659.2.0"></component></template><template v-slot:below
  path="2028347659.3"><div class="outputs" path="2028347659.3.0"><ul
  path="2028347659.3.0.0"><li class="socket" v-for="(output, index) in
  box1.sockets.outputs" :id="getSocketElementID(box1, output)"
  path="2028347659.3.0.0.0"><ui-dnd-draggable ref="dragStartHint"
  :drag-item="getOutputSocketDragItem(box1, output)" @drag-start="() =&gt;
  onDragStart(index)" @drag-end="() =&gt; onDragEnd(index)" @drag="onDrag"
  path="2028347659.3.0.0.0.0"><ui-title icon="🧊" :text="output.name"
  path="2028347659.3.0.0.0.0.0"></ui-title></ui-dnd-draggable></li></ul></div><div
  class="drag-end-hint" ref="dragEndHint"
  path="2028347659.3.1"></div><ui-leader-line v-if="isDraggingOutputSocket"
  :from-vue="dragStartHint" :to-vue="dragEndHint" line-path="fluid"
  path="2028347659.3.2"></ui-leader-line></template></ui-window>
