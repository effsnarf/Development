dom:
  div: 
    h3:
      v-text: '''Action Interpreter'''
    div: 
      ui.title:
        text: nextID
        ':number': nextID
      ui.value.any: 
        ':value': boxes
      ui.value.any: 
        ':value': links
      transition.group:
        name: list
        flow.box:
          v-for: box in boxes
          ':key': box._id
          ':box': box
        flow.link:
          v-for: link in links
          ':key': link._id
          ':link': link
props:
  actionStack: null
data:
  boxes: []
  links: []
  nextID: 1
  error: null
methods:
  create_box: | #js
    async function(action, box) {
      box = Objects.clone(box);
      const prevNextID = this.nextID;
      if (!box) box = {};
      if (!box._id) box._id = this.nextID++;
      box.sockets = {
        inputs: this.getNewSockets(box.sockets?.inputs),
        outputs: this.getNewSockets(box.sockets?.outputs)
      };
      if (box.type == "vue.comp")
      {
        const comp = this.$root.comps.find(c => (c.name == box.data.comp.name));
        box.data.name = comp.name;
        const propNames = Object.keys(comp.source.props);
        box.sockets.inputs = this.getNewSockets(propNames);
        const emitNames = this.getMethodEmitNames(comp);
        box.sockets.outputs = this.getNewSockets(emitNames);
      }
      this.boxes.add(box);
      action.undo = {
        method: "delete.box",
        args: [box._id, prevNextID]
      };
      return action;
    }
  delete_box: | #js
    async function(action, boxID, prevNextID, options) {
      const box = await this.boxes.find(b => b._id === boxID);
      await this.boxes.removeByField("_id", boxID);
      if (options.isUndoing) this.nextID = prevNextID;
      action.undo = {
        method: "create.box",
        args: [box]
      };
      return action;
    }
  move_box: | #js
    async function(action, boxID, pos) {
      const box = await this.boxes.find(b => b._id === boxID);
      action.undo = Objects.clone({
        method: "move.box",
        args: [boxID, box.rect.pos]
      });
      box.rect.pos.x = pos.x;
      box.rect.pos.y = pos.y;
      return action;
    }
  getMethodEmitNames: | #js
    function(comp) {
      const compMethodsCode = Object.values(comp.source.methods).join("\n");
      const emitRegex = /this\.\$emit\((['"])(.+?)\1/g;
      const emitNames = [...compMethodsCode.matchAll(emitRegex)].map(a => a[2])
      return emitNames;
    }
  create_link: | #js
    async function(action, fromBoxID, outputSocketID, toBoxID, inputSocketID) {
      const link = {
        _id: this.nextID++,
        from: {
          box: {
            _id: fromBoxID
          },
          socket: {
            _id: outputSocketID
          }
        },
        to: {
          box: {
            _id: toBoxID
          },
          socket: {
            _id: inputSocketID
          }
        }
      };
      this.links.add(link);
      action.undo = {
        method: "delete.link",
        args: [link._id]
      };
      return action;
    }
  delete_link: | #js
    async function(action, linkID, options) {
      const link = await this.links.find(l => l._id === linkID);
      await this.links.removeByField("_id", linkID);
      if (options.isUndoing) this.nextID--;
      action.undo = {
        method: "create.link",
        args: [link.fromBoxID, link.outputSocketID, link.toBoxID, link.inputSocketID]
      };
      return action;
    }
  update_box_data: | #js
    async function(action, boxID, data, options) {
      const box = await this.boxes.find(b => b._id === boxID);
      action.undo = Objects.clone({
        method: "update.box.data",
        args: [boxID, box.data]
      });
      Object.assign(box.data, data);
      if (box.type == "variable") {
        await this.setBoxValue(box, box.data.value);
      }
      return action;
    }
  setBoxValue: | #js
    async function(box, value) {
      box.data.value = value;
      if (box.type == "data")
      {
        const mapFunc = eval(`(${box.data.map || "(obj) => obj"})`);
        value = mapFunc(value);
      }
      await this.setSocketValue(box, box.sockets.outputs[0], value);
    }
  setSocketValue: | #js
    async function(box, socket, value) {
      socket.value = value;
      await this.propagateSocketLinks(box, socket);
    }
  propagateSocketLinks: | #js
    async function(box, socket) {
      const value = socket.value;
      const links = this.links.filter(l => l.from.box._id === box._id);
      for (const link of links)
      {
        const toBox = this.boxes.find(b => b._id === link.to.box._id);
        const toSocket = toBox.sockets.inputs.find(s => s._id === link.to.socket._id);
        if (!toSocket) continue;
        toSocket.value = value;
        if (toBox.type == "variable") {
          toBox.data.value = value;
          await this.setBoxValue(toBox, value);
        }
        if (toBox.type == "function") {
          const argValues = toBox.sockets.inputs.map(s => s.value);
          const argNames = (toBox.data.argNames || '').split(",").map(s => s.trim()).filter(s => s);
          const code = toBox.data.code;
          try
          {
            const func = eval(`(async (${argNames.join(",")}) => { ${code} })`);
            toBox.data.error = null;
            const result = await func(...argValues);
            toBox.data.result = result;
            await this.setBoxValue(toBox, result);
          }
          catch (ex)
          {
            toBox.data.error = ex.message;
          }
        }
      };
    }
  getNewSockets: | #js
    function(socketItems) {
      socketItems = socketItems || [];
      socketItems = Objects.clone(socketItems);
      socketItems = socketItems.map(item => {
        item = (typeof item === "string") ? { _id: this.nextID++, name: item } : item;
        return item;
      });
      return socketItems;
    }
  onAction: | #js
    async function(action, options) {
      const prevAction = this.actionStack.doneAction.action;
      const redo = action.redo;
      const methodName = redo.method.replace(/\./g, "_");
      let actionMethod = this[methodName];
      if (!actionMethod) {
        throw new Error(`Action method not found: ${redo.method}`);
      }
      actionMethod = actionMethod.bind(this);
      action = await actionMethod(action, ...redo.args, options);
      action.groupWithPrevAction = this.isGroupable(action, prevAction);
      return action;
    }
  isGroupable: | #js
    function(action, prevAction) {
      if (!prevAction) return false;
      const timeDiffSecs = (Date.now() - prevAction.dt) / 1000;
      //if (timeDiffSecs > 1) return false;
      const redo = action.redo;
      const prevRedo = prevAction.redo;
      if (prevRedo.method !== redo.method) return false;
      if (redo.method == "move.box")
      {
        if (redo.args[0] !== prevRedo.args[0]) return false;
        return true;
      }
      if (redo.method === "update.box.data")
      {
        if (redo.args[0] !== prevRedo.args[0]) return false;
        const data = redo.args[1];
        const prevData = prevRedo.args[1];
        if (Object.keys(data).join(",") === Object.keys(prevData).join(",")) return true;
      }
      return false;
    }
  clear: | #js
    async function(action) {
      this.boxes.clear();
      action.undo = {
        method: "clear",
        args: []
      };
      return action;
    }
  yamlify: | #js
    function(obj) {
      try
      {
        this.error = null;
        return jsyaml.dump(obj);
      }
      catch (ex)
      {
        this.error = ex.message;
      }
    }
computed:
  jsyaml: | #js
    function() {
      return jsyaml;
    }
_:
  examples:
    count: 0
name: flow-interface-action-interpreter
template: >-
  <div class="comp-flow-interface-action-interpreter" path="-713617833."><h3
  v-text="'Action Interpreter'" path="-713617833.0"></h3><div
  path="-713617833.1"><ui-title text="nextID" :number="nextID"
  path="-713617833.1.0"></ui-title><ui-value-any :value="boxes"
  path="-713617833.1.1"></ui-value-any><ui-value-any :value="links"
  path="-713617833.1.2"></ui-value-any><transition-group name="list"
  path="-713617833.1.3"><flow-box v-for="box in boxes" :key="box._id" :box="box"
  path="-713617833.1.3.0"></flow-box><flow-link v-for="link in links"
  :key="link._id" :link="link"
  path="-713617833.1.3.1"></flow-link></transition-group></div></div>
