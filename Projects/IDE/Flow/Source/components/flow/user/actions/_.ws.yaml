dom:
  div:
    v-if: showData
    h3:
      v-text: '''✨ Actions'''
    ui.value.array:
      ':value': actions
      view: table
      reverse: true
props: null
data:
  actions: []
  pointer: -1
  showData: false
mounted: | #js
  this.$root.$on("user-action", this.onUserAction);
  this.$root.$on("app-init", this.load.bind(this));
methods:
  load: | #js
    function() {
      const data = JSON.parse(localStorage.getItem("flow.user.actions") || "[]");
      this.actions = (data.actions || []);
      this.pointer = -1;
      if (this.actions[0]?.type != "no.op") this.actions.unshift({ type: "no.op" });
      this.executeUpTo((data.actions.length - 1 || 0));
    }
  save: | #js
    function() {
      localStorage.setItem("flow.user.actions", JSON.stringify({
        actions: this.actions,
        pointer: this.pointer,
      }));
    }
  toPersistableAction: | #js
    function(action) {
      return Object.fromEntries(Object.entries(action).map(([key, value]) => {
        if (value?.id) value = ({ id: value.id });
        return [key, value];
      }));
    }
  fromPersistableAction: | #js
    function(action) {
      return Object.fromEntries(Object.entries(action).map(([key, value]) => {
        if (value?.id) value = this.$gdb.getNode(value.id);
        return [key, value];
      }));
    }
  onUserAction: | #js
    function(action) {
      const lastAction = this.actions[this.actions.length - 1];
      if (this.isActionMergeable(lastAction, action)) this.actions.pop();
      action = this.toPersistableAction(action);
      // Clear actions above pointer
      this.actions = this.actions.slice(0, this.pointer + 1);
      this.actions.push(action);
      this.redo();
    }
  isActionMergeable: | #js
    function(lastAction, action) {
      if (!lastAction) return false;
      if (lastAction.type != action.type) return false;
      if (action.type != "node.update") return false;
      if (lastAction.field != action.field) return false;
      return true;
    }
  redo: | #js
    function() {
      if (this.pointer >= this.actions.length - 1) return;
      this.pointer++;
      this.doAction(this.actions[this.pointer]);
    }
  undo: | #js
    function() {
      if (this.pointer < 0) return;
      this.undoAction(this.actions[this.pointer]);
      this.pointer--;
    }
  executeUpTo: | #js
    function(index) {
      if (index < this.pointer)
      {
        while (this.pointer > index) this.undo();
      }
      else
      {
        while (this.pointer < index) this.redo();
      }
    }
  doAction: | #js
    function(action) {
      action = this.fromPersistableAction(action);
      const methodName = "on" + action.type
        .split(".")
        .map(s => s.capitalize())
        .join("");
      if (this[methodName]) this[methodName](action);
      else throw new Error("Unknown action type: " + action.type);
    }
  undoAction: | #js
    function(action) {
      alertify.error("not implemented");
    }
  onNoOp: | #js
    function(action) {
    }
  onDndDrop: | #js
    function(action) {
      const { dragItem, dropItem } = action;

      if (dragItem.type == "flow.app.compInst")
      {
        if (dropItem.type == "flow.app.compInst")
        {
          this.$gdb.addLink(dragItem, "data.send", dropItem, { event: "click" });
          return;
        }
      }

      if (dropItem == "trash")
      {
        this.$gdb.deleteNode(dragItem);
        return;
      }

      if (typeof dragItem == "string") this.onDndDrop_newNode(action);

      else this.onDndDrop_nodeToNode(action);
    }
  onDndDrop_newNode: | #js
    function(action) {
      const { dragItem, dropItem } = action;
      const newNodeType = dragItem;

      const newNode = this.createNewNode(newNodeType);

      if (dropItem.type == "flow.layout.empty")
      {
        this.$gdb.replaceNode(dropItem, newNode);
        return;
      }
      else
      {
        this.$gdb.addChildNode(dropItem, newNode);
      }
    }
  onDndDrop_nodeToNode: | #js
    function(action) {
      const { dragItem, dropItem } = action;

      if (action.dropItem.type == "flow.layout.empty")
      {
        if (action.dragItem.type == "flow.app.comp")
        {
          const compInst = this.$gdb.addNode("flow.app.compInst", {
            compID: {
              type: "noderef",
              value: {
                type: "flow.app.comp",
                value: action.dragItem.id
              }
            },
          });
          this.$gdb.replaceNode(action.dropItem, compInst);
          return;
        }
        // Move node to empty layout node
        if (action.dragItem.type.startsWith("flow.layout"))
        {
          this.$gdb.replaceNode(action.dropItem, action.dragItem);
          return;
        }
        throw new Error("Not implemented");
      }
      this.$gdb.addLink(action.dragItem, "data.send", action.dropItem);
    }
  onNodeUpdate: | #js
    function(action) {
      this.$gdb.updateNodeField(action.node, `${action.field}.value`, action.value);
    }
  createNewNode: | #js
    function(newNodeType) {
      const data = {};

      const newNode = this.$gdb.addNode(newNodeType, data);
      
      return newNode;
    }
watch:
  actions:
    handler: | #js
      function() {
        this.save();
      }
    deep: true
  pointer:
    handler: | #js
      function() {
        this.save();
      }
    deep: true
_:
  examples:
    count: 0
name: flow-user-actions
template: >-
  <div class="comp-flow-user-actions" v-if="showData" path="1351962266."><h3
  v-text="'✨ Actions'" path="1351962266.0"></h3><ui-value-array :value="actions"
  view="table" reverse="true" path="1351962266.1"></ui-value-array></div>
