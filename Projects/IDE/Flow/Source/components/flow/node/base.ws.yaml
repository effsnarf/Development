dom:
  flow.dnd.dropzone:
    v-if: node
    ':class': cssClass
    ':node': node
    @drag-over: onDragOver
    @click: onClick
    slot: null
props:
  node: null
  contextData: null
data:
  nodeDataIds: []
  nodeDatas: {}
  handlers:
    onGraphNodesChange: onGraphNodesChange
    onGraphNodeDataChange: onGraphNodeDataChange
    onHighlightedNodesChange: onHighlightedNodesChange
  twinVues: []
  linkedVues: []
  isClickable: false
  isMounted: false
  isFlashing: false
  isHighlighted: false
mounted: >
  this.isMounted = true;


  this.$root.flow.ui.registerVue(this);


  this.handlers.onGraphNodeChange = this.onGraphNodeChange.bind(this);

  this.handlers.onGraphNodeDataChange = this.onGraphNodeDataChange.bind(this);

  this.handlers.onHighlightedNodesChange =
  this.onHighlightedNodesChange.bind(this);


  this.$root.$on("flow.gdb.node.change", this.handlers.onGraphNodeChange);

  this.$root.$on("flow.user.app.runtime.data.node.data.change",
  this.handlers.onGraphNodeDataChange);

  this.$root.$on("highlighted.nodes.change",
  this.handlers.onHighlightedNodesChange);


  this.updateRelatedVues();


  this.refresh();
unmounted: >
  this.$root.flow.ui.unregisterVue(this);


  this.$root.$off("gdb.node.change", this.handlers.onGraphNodeChange);

  this.$root.$off("flow.user.app.runtime.data.node.data.change",
  this.handlers.onGraphNodeDataChange);

  this.$root.$off("highlighted.nodes.change",
  this.handlers.onHighlightedNodesChange);


  this.isMounted = false;
methods:
  getThis: | #js
    function() {
      return this;
    }
  flash: | #js
    async function() {
      if (this.isFlashing) return;
      this.isFlashing = true;
      try
      {
        const flashTimes = 1;
        const delay = 400;
        const flashOnce = (async (delayEnd = true) => {
          this.$el.classList.add("flashed");
          await this.$root.wait(delay);
          this.$el.classList.remove("flashed");
          if (delayEnd) await this.$root.wait(delay);
        });
        for (let i = 0; i < flashTimes; i++) {
          await flashOnce((i < flashTimes - 1));
        }
      }
      finally
      {
        this.isFlashing = false;
      }
    }
  updateRelatedVues: | #js
    function() {
      if (!this.isMounted) return;
      this.twinVues = this.getTwinVues().map(vue => () => vue);
      this.linkedVues = this.getLinkedVues().map(vue => () => vue);
      setTimeout(this.updateRelatedVues.bind(this), 100);
    }
  getTwinVues: | #js
    function() {
      // Twin vue means other vues that are connected to the same node.
      let vues = this.$root.flow.ui.getNodeVues(this.node, { except: this });
      vues = vues.filter(v => (v.$parent.$options._componentTag != this.$parent.$options._componentTag));
      return vues;
    }
  getLinkedVues: | #js
    function() {
      let vues = this.$root.flow.ui.getLinkedVues(this.node, { except: this });
      vues = vues.filter(v => (v.$parent.$options._componentTag != this.$parent.$options._componentTag));
      return vues;
    }
  onGraphNodeChange: | #js
    function(node) {
      if (node?.id != this.node?.id) return;
      if (this.$parent?.onNodeChange) this.$parent.onNodeChange(node);
      this.refresh();
    }
  onGraphNodeDataChange: | #js
    function(node, data) {
      if (!this.nodeDataIds.includes(node.id)) return;
      this.flash();
      this.nodeDatas[node.id] = data;
      this.$emit("node-datas", this.nodeDatas);
    }
  onHighlightedNodesChange: | #js
    function(highlightedNodes) {
      this.isHighlighted = highlightedNodes[this.node.id] > 0;
    }
  getNodeDataIds: | #js
    function() {
      // This node might be receiving data from other nodes via data.send links.
      // nodeDataIds is a list of node IDs whose data is relevant to this node.
      // That includes this node itself, and all nodes that send data to this node.
      if (!this.node) return [];
      const dataNodes = this.$gdb.getNodes("data.send", this.node);
      const dataNodeIDs = [this.node.id, ...dataNodes.map(node => node.id)].distinct();
      return dataNodeIDs;
    }
  onDragOver: | #js
    function(isDragOver) {
    }
  onClick: | #js
    function(e) {
      this.$root.flow.user.app.onNodeClick(this.node, this.contextData);
      this.$emit("click", e);
    }
  refresh: | #js
    function() {
      this.nodeDataIds = this.getNodeDataIds();
      this.$set(this, "nodeDatas", {});
      for (const id of this.nodeDataIds) {
        const data = this.$root.flow.user.app.runtimeData.nodeDatas[id];
        this.nodeDatas[id] = data;
      }
      this.isClickable = this.$root.flow.user.app.isNodeClickable(this.node);
      this.$emit("node-datas", this.nodeDatas);
    }
computed:
  cssClass: | #js
    function() {
      const cls = {};
      cls["highlighted-node"] = this.isHighlighted;
      cls.clickable = this.isClickable;
      return cls;
    }
style:
  .flashed:
    border: 1px solid white
  .highlighted-node:
    border: 2px dashed yellow !important
    box-shadow: inset -3px 3px 3px black
    background: '#ffffff20'
    transition: 0s
_:
  examples:
    count: 0
name: flow-node-base
template: >-
  <flow-dnd-dropzone class="comp-flow-node-base" v-if="node" :class="cssClass"
  :node="node" @drag-over="onDragOver" @click="onClick"
  path="674641533."><slot></slot></flow-dnd-dropzone>
