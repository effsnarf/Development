dom:
  div: 
    class: grid-module box2
    div: 
      v-if: icon && showTitle
      h3:
        ui.title:
          ':icon': icon
          ':text': compName
          ':number': getTitle()
    .module-content:
      slot: null
    div: 
      v-if: showEvents
      ':key': key1
      class: mt-l1
props:
  icon: null
  title: null
  showEvents: false
  showTitle: true
  showConsole: false
data:
  compMethodArgNames: {}
  isFemitting: false
  femitQueue: []
  femitDelay: 1
  key1: 1
mounted: | #js
  function() {
    const self = this;
    // $femit is an emit that goes through the grid
    // Other components listen to events by method names (compName_emitName)
    this.$parent.$femit = async (eventName, ...args) => {
      const compName = this.compName;
      args = Objects.clone(args);
      const femit = Objects.clone({ compName: this.compName, eventName, args });
      this.$root.$emit("grid.event", femit.compName, femit.eventName, femit.args);
      return;
      this.femitQueue.push(femit);
      this.nextFemit();
      //this.$root.$emit(emitName, ...args);
    };

    // const handlerNames = Object.keys(this.$parent)
    //   .filter(k => !k.startsWith("_"))
    //   .filter(k => k.includes("_"));
    
    // for (const handlerName of handlerNames) {
    //   const method = this.$parent[handlerName].bind(this.$parent);
    //   console.log("ðŸ”´", handlerName);
    //   this.$root.$on(handlerName, (...args) => {
    //     method(...args);
    //   });
    // }
    // #TODO: Instead of listening to all events, add listeners by method/event names
    if (!this._onGridEvent) this._onGridEvent = this.onGridEvent.bind(this);
    this.$root.$on("grid.event", this._onGridEvent);
  }
unmounted: | #js
  function() {
    alertify.error("unmounted");
    this.$root.$off("grid.event", this._onGridEvent);
  }
methods:
  nextFemit: | #js
    function(internal) {
      if ((!internal) && this.isFemitting) return;
      if (!this.femitQueue.length) {
        this.isFemitting = false;
        return;
      }
      this.isFemitting = true;
      const femit = this.femitQueue.shift();
      const emitName = `${femit.compName}_${femit.eventName}`.replace(/\./g, "_");
      //console.log("ðŸŸ¢", emitName, femit.args)
      this.$root.$emit("grid.event", femit.compName, femit.eventName, femit.args);
      setTimeout((() => {
        this.nextFemit(true);
      }).bind(this), this.femitDelay);
    }
  getTitle: | #js
    function() {
      if (this.title) return this.title;
      if (this.userID) return this.userID;
      return null;
    }
  onGridEvent: | #js
    async function(compName, eventName, args) {
      // Vue still holds the component instance even if it's not rendered on the page anymore
      // In this case, we don't pass grid events to the component
      if (!this.$el.isConnected) return;

      if (["ui.mouse"].includes(compName)) return;

      const vue = this.$parent;

      if (eventName == "to")
      {
        const to = {
          compName: args[0],
          fuid: args[1],
          methodName: args[2],
          args: args[3],
        };
        
        if (to.compName != vue.$data._.comp.name) return;
        if (to.fuid != vue.fuid) return;

        const method = vue[to.methodName];
        if (!method) throw new Error(`Method not found: ${to.methodName}`);
        
        //console.log("ðŸ”´", to.compName, "ðŸš€", vue.$data._.comp.name, to.methodName, to.args)
        await (method.bind(vue))(...(to.args||[]));

        return;
      }

      if (vue.onAllEvents) {
        vue.onAllEvents(compName, eventName, args);
      }

      const methodName = `${compName}_${eventName}`.replace(/\./g, "_");
      const method = vue[methodName];
      if (!method) return;

      const targetCompName = vue.$data._.comp.name;

      //console.log("ðŸ”´", targetCompName, compName, "ðŸš€", eventName, args);

      const argNames = this.getCompMethodArgNames(vue.$data._.comp.name, methodName);

      // This checks all vues for a userID prop
      // On the server we'll have the modules separated by userID to begin with
      if (argNames[0] == "userID") {
        if ("userID" in vue)
        {
          if (args[0] != vue.userID) return;
        }
      }
      
      (method.bind(vue))(...args);
    }
  onAllEvents: | #js
    function(compName, emitName, args) {
      const methodName = `${compName}_${emitName}`.replace(/\./g, "_");
      if (this.$parent[methodName]) {
        // Module caught an event
        this.femitsInLog[emitName] = args;
        this.$refs.console1?.log("âž–", compName, emitName);
      }
    }
  getCompMethodArgNames: | #js
    function(compName, methodName) {
      const key = `${compName}.${methodName}`;
      if (this.compMethodArgNames[key]) return this.compMethodArgNames[key];
      const methodStr = this.$root.comps
        .find(c => (c.name == compName))
        .source
        .methods[methodName];
      const argNamesRegex = /function\((.*)\)/;
      const argNames = methodStr.match(argNamesRegex)[1]
        .split(",")
        .map(a => a.trim());
      this.compMethodArgNames[key] = argNames;
      return argNames;
    }
computed:
  compName: | #js
    function() {
      return this.$parent?.$data?._?.comp?.name;
    }
  userID: | #js
    function() {
      return this.$parent?.userID;
    }
style:
  h3:
    font-weight: normal
  .log-box:
    max-height: 10em
    overflow: auto
  .box2:
    margin: 0.5em
    border: '1px transparent #ccc'
  .box2 > *:
    margin-left: 0em
_:
  examples:
    count: 0
name: grid-module
template: >-
  <div class="comp-grid-module grid-module box2" path="1449764372."><div
  v-if="icon &amp;&amp; showTitle" path="1449764372.0"><h3
  path="1449764372.0.0"><ui-title :icon="icon" :text="compName"
  :number="getTitle()" path="1449764372.0.0.0"></ui-title></h3></div><div
  class="module-content" path="1449764372.1"><slot></slot></div><div
  class="mt-l1" v-if="showEvents" :key="key1" path="1449764372.2"></div></div>
