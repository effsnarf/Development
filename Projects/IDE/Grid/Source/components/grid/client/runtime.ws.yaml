dom:
  grid.module:
    icon: 🏃‍♂️
    grid.data.list.view: 
      ':fuid': userID + '/data/boxes'
      v-model: boxes
    grid.data.list.view: 
      ':fuid': userID + '/data/links'
      v-model: links
props:
  userID: null
data:
  socket:
    runtime:
      data: {}
  boxes: []
  links: []
mounted: | #js
  function() {
    this.$root.socket = this.socket;
  }
methods:
  grid_ui_box_execute: | #js
    function(boxID) {
      const box = this.getBox(boxID);
      const method = this[`grid_ui_box_execute_${box.type}`];
      if (!method) throw new Error(`Unknown box type: ${box.type}`);
      method.call(this, boxID);
    }
  grid_ui_box_socket_value_change: | #js
    function(boxID, socketDirection, sID, socketValue) {
      this.setSocketValue(boxID, socketDirection, sID, socketValue);
    }
  grid_ui_box_execute_text: | #js
    function(boxID) {
      this.propagateSocketLinks(boxID, "output", 1);
    }
  grid_ui_box_execute_func: | #js
    function(boxID) {
      this.processBoxChange_func(this.getBox(boxID));
    }
  setSocketValue: | #js
    function(boxID, sDirection, sID, sValue) {
      this.ensure(boxID);
      const box = this.getBox(boxID);
      this.socket.runtime.data
        [boxID]
        [sDirection]
        [sID] =
          sValue;
      this.onSocketValueChange(boxID, sDirection, sID, sValue);
    }
  onSocketValueChange: | #js
    function(boxID, sDirection, sID, sValue) {
      this.$femit("socket.value.change", boxID, sDirection, sID, sValue);
      this.processBoxChange(boxID, sDirection, sID, sValue);
      this.propagateSocketLinks(boxID, sDirection, sID);
    }
  processBoxChange: | #js
    async function(boxID, sDirection, sID, sValue) {
      const box = this.getBox(boxID);
      if (!box) return;

      if (box.type == "data")
      {
        if (sDirection == "input" && sID == 1)
        {
          this.setSocketValue(boxID, "output", 1, sValue);
        }
      }

      if (box.type == "func")
      {
        if (sDirection == "input")
        {
          this.processBoxChange_func(box);
        }
      }
    }
  propagateSocketLinks: | #js
    function(boxID, sDirection, sID) {
      if (sDirection != "output") return;

      const box = this.getBox(boxID);

      const sValue = this.socket.runtime.data[boxID][sDirection][sID];

      const links = this.links
        .filter((link) => link.from.box._id === boxID)
        .filter((link) => link.from.socket._id == sID);

      for (const link of links) {
        this.$femit("link.flash", link._id, sValue);
        this.setSocketValue(link.to.box._id, "input", link.to.socket._id, sValue);
      }
    }
  processBoxChange_func: | #js
    async function(box) {
      const result = await this.runFunc(box);
      this.setSocketValue(box._id, "output", 1, result);
      this.$femit("func.result.change", box._id, result);
    }
  runFunc: | #js
    async function(box) {
      try
      {
        this.$femit("box.error", box._id, null);
        this.$femit("box.is.loading", box._id, true);

        const runtimeData = this.socket.runtime.data[box._id];

        const argNames = box.argNames;
        const argValues = Object.values(runtimeData?.input||{});

        const result = (box.runs.on == "server")
          ? await this.runFuncOnServer(box, argNames, argValues, box.code)
          : await this.runFuncOnClient(box, argNames, argValues, box.code);

        return result;
      }
      catch (ex)
      {
        const ideEx = {};
        ideEx.message = ex.message;
        ideEx.stack = ex.stack;
        this.$femit("box.error", box._id, ideEx);
      }
      finally
      {
        this.$femit("box.is.loading", box._id, false);
      }
    }
  runFuncOnServer: | #js
    async function(box, argNames, argValues, code) {
      try
      {
        const response = await fetch("/execute/code", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            argNames,
            argValues,
            code,
          }),
        });
        const result = await response.json();
        return result;
      }
      catch (ex)
      {
        const message = ex.message.split('\n')[0];
        throw new Error(message);
      }
    }
  runFuncOnClient: | #js
    async function(box, argNames, argValues, code) {
      const func = eval(
        `(async function(${argNames.join(", ")}) { ${code} })`
      );

      const result = await func(...argValues);

      return result;
    }
  getSocketRuntimeData: | #js
    function(boxID) {
      let runtimeData = this.socket.runtime.data[boxID];
      if (!runtimeData) {
        runtimeData = {
          input: {},
          output: {},
        };
        this.$set(this.socket.runtime.data, boxID, runtimeData);
      }
      return runtimeData;
    }
  getBox: | #js
    function(boxID) {
      // #TODO: Slow
      return this.boxes.find((box) => box._id === boxID);
    }
  ensure: | #js
    function(boxID) {
      this.getSocketRuntimeData(boxID);
    }
watch:
  boxes:
    handler: | #js
      function(boxes) {
        this.$root.boxes = boxes;
      }
    immediate: true
  links:
    handler: | #js
      function(links) {
        this.$root.links = links;
      }
    immediate: true
_:
  examples:
    count: 0
name: grid-client-runtime
template: >-
  <grid-module class="comp-grid-client-runtime" icon="🏃‍♂️"
  path="-1405898659."><grid-data-list-view :fuid="userID + '/data/boxes'"
  v-model="boxes"
  path="-1405898659.0"></grid-data-list-view><grid-data-list-view :fuid="userID
  + '/data/links'" v-model="links"
  path="-1405898659.1"></grid-data-list-view></grid-module>
