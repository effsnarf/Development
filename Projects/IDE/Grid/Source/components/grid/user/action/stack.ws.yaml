dom:
  grid.module:
    icon: ðŸ‘¤ðŸ‘ˆ
    grid.data.list.view: 
      ':fuid': userID+'/data/boxes'
      v-model: boxes
    grid.data.list.view: 
      ':fuid': userID+'/user/actions'
      v-model: userActions
props:
  userID: null
data:
  nextActionID: 1
  nextID: 1
  userActions: []
  boxes: []
  pointer: -1
methods:
  create_box: | #js
    async function(userID, action, box) {
      box._id = this.nextID++;
      this.$femit("to", "grid.data.list", `${userID}/data/boxes`, "add", [box]);
      action.undo = { method: "delete.box", args: [box._id] };
      return action;
    }
  move_box: | #js
    async function(userID, action, boxID, pos) {
      const box = this.boxes.find((box) => box._id === boxID);
      const oldPos = box.rect.pos;
      this.$femit("to", "grid.data.list", `${userID}/data/boxes`, "update", [boxID, { rect: { pos } }]);
      action.undo = { method: "move.box", args: [boxID, oldPos] };
      return action;
    }
  delete_box: | #js
    async function(userID, action, boxID) {
      this.$femit("to", "grid.data.list", `${userID}/data/boxes`, "delete", [boxID]);
      action.undo = { method: "no.op" };
      return action;
    }
  edit_box: | #js
    async function(userID, action, boxID, data) {
      const box = this.boxes.find((box) => box._id === boxID);
      const oldData = { ...box };
      const changes = DeepDiff.diff(oldData, data);
      //for (const change of changes) DeepDiff.applyChange(box, change);
      this.$femit("to", "grid.data.list", `${userID}/data/boxes`, "update", [boxID, data]);
      action.undo = { method: "edit.box", args: [boxID, oldData] };
      return action;
    }
  grid_user_actions_do: | #js
    async function(userID, action, addToStack = true, overwriteRedoActions) {
      action._id = this.nextActionID++;

      const hasRedoActions = (this.pointer < this.userActions.length - 1);

      if (hasRedoActions) {
        // When deleting the next redo actions from the stack, we're emitting to data.list
        // which we don't know how long it could take (could go to the server)
        // so we're invoking the method again after a timeout
        if (overwriteRedoActions)
        {
          setTimeout(() => {
            this.grid_user_actions_do(userID, action, addToStack);
          }, 100);
          return;
        }
        const question = `This will delete ${this.userActions.length - this.pointer - 1} redo actions from the stack:
        ${this.userActions.slice(this.pointer + 1)
          .map((action) => action.redo.method)
          .map((method) => `[${method}]`)
          .join("\n")}
        Are you sure?`
          .replace(/\n/g, "<br/>");
        alertify.confirm(question, () => {
          const actionIDs = this.userActions
            .slice(this.pointer + 1)
            .map((action) => action._id);
          this.$femit("to", "grid.data.list", `${userID}/user/actions`, "delete", actionIDs);
          setTimeout(() => {
            this.grid_user_actions_do(userID, action, addToStack, true);
          }, 100);
        });
        return;
      }
      const redo = action.redo;
      const methodName = redo.method.replace(/\./g, "_");
      const method = this[methodName];
      if (!method) {
        const errorMessage = `Method ${methodName} not found on grid.user.action.stack`;
        alertify.error(errorMessage);
        throw new Error(errorMessage);
        return;
      }
      action = await method.apply(this, [userID, action, ...redo.args]);
      if (addToStack) {
        this.$femit("to", "grid.data.list", `${userID}/user/actions`, "add", [action]);
        this.pointer++;
      }
    }
  grid_user_actions_undo: | #js
    async function(userID) {
      if (this.pointer < 0) {
        alertify.error("No more actions to undo");
        return;
      }
      const lastAction = this.userActions[this.pointer];
      const undoAction = { redo: lastAction.undo };
      await this.grid_user_actions_do(userID, undoAction, false);
      this.pointer--;
    }
  grid_user_actions_redo: | #js
    async function(userID) {
      if (this.pointer >= this.userActions.length - 1)
      {
        alertify.error("No more actions to redo");
        return;
      }
      const nextAction = this.userActions[this.pointer + 1];
      await this.grid_user_actions_do(userID, nextAction, false);
      this.pointer++;
    }
  grid_user_actions_clear: | #js
    function() {
      debugger;
    }
computed: null
_:
  examples:
    count: 0
name: grid-user-action-stack
template: >-
  <grid-module class="comp-grid-user-action-stack" icon="ðŸ‘¤ðŸ‘ˆ"
  path="-1764928149."><grid-data-list-view :fuid="userID+'/data/boxes'"
  v-model="boxes"
  path="-1764928149.0"></grid-data-list-view><grid-data-list-view
  :fuid="userID+'/user/actions'" v-model="userActions"
  path="-1764928149.1"></grid-data-list-view></grid-module>
