dom:
  grid.module:
    icon: ðŸ‘¤ðŸ‘ˆ
    grid.data.list.view: 
      ':fuid': userID+'/data/boxes'
      v-model: boxes
    grid.data.list.view: 
      ':fuid': userID+'/data/links'
      v-model: links
    .flex:
      grid.data.list:
        ':fuid': userID+'/user/actions'
        v-model: userActions
      grid.data.variable: 
        ':fuid': userID+'/user/actions/pointer'
        ':default-value': -1
        v-model: pointer
      grid.data.variable: 
        ':fuid': userID+'/user/actions/next/id'
        ':default-value': 1
        v-model: nextID
      grid.data.variable: 
        ':fuid': userID+'/user/actions/next/action/id'
        ':default-value': 1
        v-model: nextActionID
props:
  userID: null
data:
  nextActionID: 1
  nextID: 1
  userActions: []
  boxes: []
  links: []
  pointer: null
mounted: | #js
  async function() {
    setTimeout(async () => {
      const lastDoneAction = this.lastDoneAction;
      if (!lastDoneAction) return;
      //this.pointer = -1;
      //await this.doUntil(lastDoneAction?._id);
    }, 1500);
  }
methods:
  create_group: | #js
    function(userID, action, displayBoxID) {
      const selectedBoxes = this.boxes.filter((box) => box.is?.selected);
      const selectedBoxIDs = selectedBoxes.map((box) => box._id);

      const memberBoxes = selectedBoxes;
      const memberBoxIDs = memberBoxes.map((box) => box._id);
      const memberLinks = this.links.filter((link) => memberBoxIDs.includes(link.from.box._id) && memberBoxIDs.includes(link.to.box._id));
      const memberLinkIDs = memberLinks.map((link) => link._id);
      const relatedLinks = this.links.filter((link) => memberBoxIDs.includes(link.from.box._id) || memberBoxIDs.includes(link.to.box._id));
      if (relatedLinks.length > memberLinks.length) {
        const errorMessage = `A new group must be independent from other boxes.`;
        alertify.error(errorMessage);
        throw new Error(errorMessage);
      }

      const type = "group";
      const displayBox = this.getBox(displayBoxID);
      const name = displayBox.name;
      const rect = Objects.clone(displayBox.rect);

      const sockets = this.getNewSockets(type);
      const addExportedMemberSockets = (direction) => {
        for (const memberBox of memberBoxes)
        {
          const memberBoxSockets = memberBox.sockets[direction];
          for (const memberBoxSocket of memberBoxSockets)
          {
            if (!memberBoxSocket.is?.exported) continue;
            const socket = Objects.clone(memberBoxSocket);
            socket._id = sockets[direction].length + 1;
            socket.is.exported = false;
            socket.imported = {
              from: {
                box: { _id: memberBox._id },
                socket: { _id: memberBoxSocket._id }
              }
            }
            sockets[direction].push(socket);
          }
        }
      }
      addExportedMemberSockets("input");
      addExportedMemberSockets("output");

      const groupBox = {
        _id: this.nextID++,
        type,
        name,
        rect,
        sockets: sockets,
        members: selectedBoxes.map((box) => box._id),
        displayBoxID: displayBox._id,
      };

      this.$femit("to", "grid.data.list", `${userID}/data/boxes`, "add", [groupBox]);
      this.$femit("to", "grid.data.list", `${userID}/data/boxes`, "update", [memberBoxIDs, { groupBoxID: groupBox._id, rect: { is: { grouped: true } } } ]);
      this.$femit("to", "grid.data.list", `${userID}/data/links`, "update", [memberLinkIDs, { groupBoxID: groupBox._id, is: { grouped: true } }]);
      
      this.$femit("new.box.created", groupBox);

      // Unselect the boxes
      this.select_boxes(userID, {}, selectedBoxIDs, false);

      action.undo = { method: "delete.group", args: [groupBox._id] };

      return action;
    }
  delete_group: | #js
    function(userID, action, groupBoxID, options) {
      const groupBox = this.getBox(groupBoxID);
      // Select the boxes
      this.select_boxes(userID, {}, groupBox.members, true);
      // Select the inside links
      const memberLinks = this.links.filter((link) => groupBox.members.includes(link.from.box._id) && groupBox.members.includes(link.to.box._id));
      const memberLinkIDs = memberLinks.map((link) => link._id);
      // Unset the groupBoxID on the members and links
      this.$femit("to", "grid.data.list", `${userID}/data/boxes`, "update", [groupBox.members, { groupBoxID: null, rect: { is: { grouped: false } } } ]);
      this.$femit("to", "grid.data.list", `${userID}/data/links`, "update", [memberLinkIDs, { groupBoxID: null, is: { grouped: false } } ]);
      // Delete the group box
      this.delete_box(userID, {}, groupBoxID, options);
      action.undo = { method: "no.op" };
      return action;
    }
  getDisplayBox: | #js
    function(boxes) {
      const dataBox = boxes.find((box) => box.type == "data");
      if (dataBox) return dataBox;
      throw new Error("No data box found");
    }
  create_box: | #js
    async function(userID, action, box) {
      if (!box._id) {
        box._id = this.nextID++;
        action.redo.args[0] = box;
      }

      box.rect.is.minimized = false;
      box.rect.is.visible = true;
      box.rect.is.grouped = false;

      this.$femit("to", "grid.data.list", `${userID}/data/boxes`, "add", [box]);
      
      this.$femit("new.box.created", box);

      action.undo = { method: "delete.box", args: [box._id] };

      return action;
    }
  move_box: | #js
    async function(userID, action, boxID, pos) {
      const box = this.boxes.find((box) => box._id === boxID);
      const oldPos = box.rect.pos;
      this.$femit("to", "grid.data.list", `${userID}/data/boxes`, "update", [boxID, { rect: { pos } }]);
      action.undo = { method: "move.box", args: [boxID, oldPos] };
      return action;
    }
  resize_box: | #js
    async function(userID, action, boxID, size) {
      const box = this.boxes.find((box) => box._id === boxID);
      const oldSize = box.rect.size;
      this.$femit("to", "grid.data.list", `${userID}/data/boxes`, "update", [boxID, { rect: { size } }]);
      action.undo = { method: "resize.box", args: [boxID, oldSize] };
      return action;
    }
  delete_box: | #js
    async function(userID, action, boxID, options) {
      if (!options.isUndoing) throw new Error("Not implemented");
      if (options.isUndoing) this.nextID--;
      const box = this.getBox(boxID);
      this.$femit("to", "grid.data.list", `${userID}/data/boxes`, "delete", [boxID]);
      action.undo = { method: "no.op" };
      this.$femit("box.deleted", box);
      return action;
    }
  edit_box: | #js
    async function(userID, action, boxID, newData, oldData) {
      // If we're changing the box type, set default sockets
      if (newData.type)
      {
        Object.assign(newData, this.getDefaultBoxData(newData.type));
        newData.sockets = this.getNewSockets(newData.type);
      }
      const box = this.boxes.find((box) => box._id === boxID);
      oldData = oldData ||
        Objects.getPropertiesAsTree(box, Objects.getPaths(newData));
      //for (const change of changes) DeepDiff.applyChange(box, change);
      this.$femit("to", "grid.data.list", `${userID}/data/boxes`, "update", [boxID, newData]);
      action.undo = { method: "edit.box", args: [boxID, oldData, newData] };
      return action;
    }
  edit_socket: | #js
    async function(userID, action, boxID, direction, socketID, newData, oldData)
    {
      const box = this.boxes.find((box) => box._id === boxID);
      const socket = box.sockets[direction].find((socket) => socket._id === socketID);
      const socketIndex = box.sockets[direction].findIndex((socket) => socket._id === socketID);
      oldData = oldData ||
        Objects.getPropertiesAsTree(socket, Objects.getPaths(newData));
      //for (const change of changes) DeepDiff.applyChange(socket, change);
      const updateData = { sockets: { [direction]: { [socketIndex]: newData } } };
      this.$femit("to", "grid.data.list", `${userID}/data/boxes`, "update", [boxID, updateData]);
      action.undo = { method: "edit.socket", args: [boxID, direction, socketID, oldData, newData] };
      return action;
    }
  select_boxes: | #js
    async function(userID, action, boxIDs, isSelected) {
      // #TODO: Undo should set the boxes that were selected before
      const boxes = this.boxes.filter((box) => boxIDs.includes(box._id));
      this.$femit("to", "grid.data.list", `${userID}/data/boxes`, "update", [boxIDs, { is: { selected: isSelected } }]);
      action.undo = { method: "select.boxes", args: [boxIDs, !isSelected] };
      return action;
    }
  unselect_boxes: | #js
    async function(userID, action) {
      const selectedBoxes = this.boxes.filter((box) => box.is?.selected);
      const boxIDs = selectedBoxes.map((box) => box._id);
      this.$femit("to", "grid.data.list", `${userID}/data/boxes`, "update", [boxIDs, { is: { selected: false } }]);
      action.undo = { method: "select.boxes", args: [boxIDs, true] };
      return action;
    }
  create_link: | #js
    async function(userID, action, from, to, linkData) {
      const link = { from, to };
      if (linkData) Object.assign(link, linkData);
      link._id = this.nextID++;
      link.is = (link.is || {});
      link.is.grouped = false;
      this.$femit("to", "grid.data.list", `${userID}/data/links`, "add", [link]);
      action.undo = { method: "delete.link", args: [link._id] };
      this.$femit("new.link.created", link);
      return action;
    }
  delete_link: | #js
    async function(userID, action, linkID, options) {
      if (options.isUndoing) this.nextID--;
      const oldLink = Objects.clone(this.links.find((link) => link._id === linkID));
      delete oldLink._id;
      this.$femit("to", "grid.data.list", `${userID}/data/links`, "delete", [linkID]);
      action.undo = { method: "create.link", from: oldLink.from, to: oldLink.to, oldLink };
      return action;
    }
  delete_selected: | #js
    async function(userID, action) {
      alertify.message('mike hunt');
      return;
      const boxes = this.boxes.filter((box) => box.rect.is.selected);
      const boxIDs = boxes.map((box) => box._id);
      const links = this.links.filter((link) => boxIDs.includes(link.from) || boxIDs.includes(link.to));
      const linkIDs = links.map((link) => link._id);
      this.$femit("to", "grid.data.list", `${userID}/data/boxes`, "delete", [boxIDs]);
      this.$femit("to", "grid.data.list", `${userID}/data/links`, "delete", [linkIDs]);
      action.undo = { method: "no.op" };
      return action;
    }
  grid_user_actions_do: >
    async function(userID, action, addToStack = true, overwriteRedoActions =
    false, options) {
      if (!action._id) action._id = this.nextActionID++;

      if (addToStack && (this.nextRedoAction) && (this.nextRedoAction._id != action._id)) {
        // When deleting the next redo actions from the stack, we're emitting to data.list
        // which we don't know how long it could take (could go to the server)
        // so we're invoking the method again after a timeout
        if (overwriteRedoActions)
        {
          setTimeout(() => {
            this.grid_user_actions_do(userID, action, addToStack);
          }, 100);
          return;
        }
        
        const deleteNextActions = () => {
          const actionIDs = this.userActions
            .slice(this.pointer + 1)
            .map((action) => action._id);

          this.$femit("to", "grid.data.list", `${userID}/user/actions`, "delete", actionIDs);
          setTimeout(() => {
            this.grid_user_actions_do(userID, action, addToStack, true);
          }, 100);
        };

        const askUser = (this.nextRedoActions.length > 5);

        if (!askUser) {
          deleteNextActions();
          return;
        }

        const question = `This will delete ${this.userActions.length - this.pointer - 1} redo actions from the stack:
        ${this.userActions.slice(this.pointer + 1)
          .map((action) => action.redo.method)
          .map((method) => `[${method}]`)
          .join("\n")}
        Are you sure?`
          .replace(/\n/g, "<br/>");

        alertify.confirm(question, deleteNextActions);
        
        return;
      }

      const redo = action.redo;
      const methodName = redo.method.replace(/\./g, "_");
      const method = this[methodName];
      if (!method) {
        const errorMessage = `Method ${methodName} not found on grid.user.action.stack`;
        alertify.error(errorMessage);
        throw new Error(errorMessage);
        return;
      }

      action = Objects.clone(action);
      
      action = await method.apply(this, [userID, action, ...redo.args, options]);

      if (!action) throw new Error(`Implementer method ${methodName} must return an action`);

      if (addToStack) {
        this.addToStack(action);
      }

      this.$femit("do", action);

      return action;
    }
  grid_user_actions_undo: | #js
    async function(userID) {
      if (this.pointer < 0) {
        alertify.error("No more actions to undo");
        return;
      }
      const lastAction = this.userActions[this.pointer];
      const undoAction = { redo: lastAction.undo };
      await this.grid_user_actions_do(userID, undoAction, false, false, { isUndoing: true });
      this.pointer--;
    }
  grid_user_actions_redo: | #js
    async function(userID) {
      if (!this.hasRedoActions)
      {
        alertify.error("No more actions to redo");
        return;
      }
      const nextAction = this.userActions[this.pointer + 1];
      const doneAction = await this.grid_user_actions_do(userID, nextAction, false);
      // We need to update the undo
      this.updateStack(nextAction._id, { undo: doneAction.undo });
      this.pointer++;
    }
  grid_user_actions_clear: | #js
    function(userID) {
      if (this.userActions.length == 0) return;

      const clearAll = () => {
        this.$femit("to", "grid.data.variable", `${userID}/user/actions/pointer`, "clear", []);
        this.$femit("to", "grid.data.variable", `${userID}/user/actions/next/id`, "clear", []);
        this.$femit("to", "grid.data.variable", `${userID}/user/actions/next/action/id`, "clear", []);
        this.$femit("to", "grid.data.list", `${userID}/user/actions`, "clear", []);
        this.$femit("to", "grid.data.list", `${userID}/data/boxes`, "clear", []);
        this.$femit("to", "grid.data.list", `${userID}/data/links`, "clear", []);
      }

      alertify.confirm("This will delete all actions from the stack. Are you sure?", clearAll);
    }
  doUntil: | #js
    async function(actionID) {
      if (!actionID) return;
      if (!this.nextAction) return;
      while (this.nextAction && (this.nextAction._id != actionID))
      {
        await this.$nextTick();
        await this.grid_user_actions_redo(this.userID);
      }
      await this.$nextTick();
      await this.grid_user_actions_redo(this.userID);
    }
  addToStack: | #js
    function(action) {
      const userID = this.userID;
      const lastAction = this.userActions[this.pointer];
      if (lastAction && this.isGroupable(action, lastAction)) {
        action = this.groupActions(action, lastAction);
        this.$femit("to", "grid.data.list", `${userID}/user/actions`, "delete", [lastAction._id]);
        this.pointer--;
      }
      this.$femit("to", "grid.data.list", `${userID}/user/actions`, "add", [action]);
      this.pointer++;
    }
  updateStack: | #js
    function(actionID, changes) {
      const userID = this.userID;
      this.$femit("to", "grid.data.list", `${userID}/user/actions`, "update", [actionID, changes]);
    }
  isGroupable: | #js
    function(action, lastAction) {
      if (!lastAction) return false;
      if (action.redo.method != lastAction.redo.method) return false;
      if (["edit.box", "resize.box", "move.box"].includes(action.redo.method))
      {
        // box._id
        if (action.redo.args[0] != lastAction.redo.args[0]) return false;
        if (Object.keys(action.redo.args[1]).join(",") != Object.keys(lastAction.redo.args[1]).join(",")) return false;
        return true;
      }
      return false;
    }
  groupActions: | #js
    function(action, lastAction) {
      action = Objects.clone(action);
      action.undo = Objects.clone(lastAction.undo);
      return action;
    }
  getDefaultBoxData: | #js
    function(type) {
      switch (type) {
        case "text":
          return {
            value: null,
            rect: {
              is: {
                minimized: true
              }
            }
          }
        case "data":
          return {
            value: null,
            rect: {
              is: {
                minimized: false
              }
            }
          }
        case "func":
          return {
            argNamesStr: "",
            argNames: [],
            code: "",
            runs: {
              on: "client"
            },
            rect: {
              is: {
                minimized: true
              }
            }
          }
        case "view.items":
          return {
            rect: {
              is: {
                minimized: false
              }
            }
          }
        case "view.image":
          return {
            url: null,
            rect: {
              is: {
                minimized: false
              }
            }
          }
        case "view.label":
          return {
            text: null,
            field: null,
            rect: {
              is: {
                minimized: true
              }
            }
          }
        case "view.layout":
          return {
            rect: {
              is: {
                minimized: false
              }
            }
          }
      }
      throw new Error(`Unknown box type: ${type}`);
    }
  getNewSockets: | #js
    function(type) {
      switch (type) {
        case "group":
          return {
            input: [
            ],
            output: [
            ]
          }
        case "text":
          return {
            input: [
              { _id: 1, type: "data", name: "text", is: { exported: false } }
            ],
            output: [
              { _id: 1, type: "data", name: "text", is: { exported: false } }
            ]
          }
        case "data":
          return {
            input: [
              { _id: 1, type: "data", name: "data", is: { exported: false } }
            ],
            output: [
              { _id: 1, type: "data", name: "data", is: { exported: false } }
            ]
          }
        case "func":
          return {
            input: [
              { _id: 1, type: "data", name: "arg0", is: { exported: false } }
            ],
            output: [
              { _id: 1, type: "data", name: "result", is: { exported: false } }
            ]
          }
        case "view.items":
          return {
            input: [
              { _id: 1, type: "data", name: "items", is: { exported: false } }
            ],
            output: [
              { _id: 1, type: "iterator", name: "item", is: { exported: false } },
              { _id: 2, type: "data", name: "hovered item", is: { exported: false } },
              { _id: 3, type: "data", name: "selected item", is: { exported: false } },
            ]
          }
        case "view.image":
          return {
            input: [
              { _id: 1, type: "data", name: "url", is: { exported: false } }
            ],
            output: [
              { _id: 1, type: "view", name: "image", is: { exported: false } }
            ]
          }
        case "view.label":
          return {
            input: [
              { _id: 1, type: "data", name: "text", is: { exported: false } },
            ],
            output: [
              { _id: 1, type: "view", name: "view", is: { exported: false } }
            ]
          }
        case "view.layout":
          return {
            input: [
              { _id: 1, type: "view", name: "slot 1" },
              { _id: 2, type: "view", name: "slot 2" },
            ],
            output: [
              { _id: 1, type: "view", name: "view" },
            ]
          }
      }
      throw new Error(`Unknown box type: ${type}`);
    }
  getBox: | #js
    function(boxID) {
      return this.boxes.find((box) => box._id === boxID);
    }
computed:
  hasRedoActions: | #js
    function() {
      return (this.nextRedoActions.length > 0);
    }
  lastDoneAction: | #js
    function() {
      return this.userActions[this.pointer];
    }
  nextRedoAction: | #js
    function() {
      return this.nextRedoActions[0];
    }
  nextRedoActions: | #js
    function() {
      return this.userActions.slice(this.pointer + 1);
    }
  nextAction: | #js
    function() {
      return this.nextRedoActions[0];
    }
watch:
  userActions:
    handler: | #js
      async function() {
      }
    deep: true
_:
  examples:
    count: 0
name: grid-user-action-stack
template: >-
  <grid-module class="comp-grid-user-action-stack" icon="ðŸ‘¤ðŸ‘ˆ"
  path="-1764928149."><grid-data-list-view :fuid="userID+'/data/boxes'"
  v-model="boxes"
  path="-1764928149.0"></grid-data-list-view><grid-data-list-view
  :fuid="userID+'/data/links'" v-model="links"
  path="-1764928149.1"></grid-data-list-view><div class="flex"
  path="-1764928149.2"><grid-data-list :fuid="userID+'/user/actions'"
  v-model="userActions"
  path="-1764928149.2.0"></grid-data-list><grid-data-variable
  :fuid="userID+'/user/actions/pointer'" :default-value="-1" v-model="pointer"
  path="-1764928149.2.1"></grid-data-variable><grid-data-variable
  :fuid="userID+'/user/actions/next/id'" :default-value="1" v-model="nextID"
  path="-1764928149.2.2"></grid-data-variable><grid-data-variable
  :fuid="userID+'/user/actions/next/action/id'" :default-value="1"
  v-model="nextActionID"
  path="-1764928149.2.3"></grid-data-variable></div></grid-module>
