dom:
  grid.module:
    icon: ðŸ‘¤ðŸ‘ˆ
    grid.data.list.view:
      ':fuid': userID+'/data/boxes'
      v-model: boxes
    .flex:
      grid.data.list:
        ':fuid': userID+'/user/actions'
        v-model: userActions
      grid.data.variable:
        ':fuid': userID+'/user/actions/pointer'
        ':default-value': -1
        v-model: pointer
props:
  userID: null
data:
  nextActionID: 1
  nextID: 1
  userActions: []
  boxes: []
  pointer: null
mounted: | #js
  async function() {
    setTimeout(async () => {
      const lastDoneAction = this.lastDoneAction;
      if (!lastDoneAction) return;
      this.pointer = -1;
      await this.doUntil(lastDoneAction?._id);
    }, 1500);
  }
methods:
  create_box: | #js
    async function(userID, action, box) {
      if (!box._id) {
        box._id = this.nextID++;
        action.redo.args[0] = box;
      }
      this.$femit("to", "grid.data.list", `${userID}/data/boxes`, "add", [box]);
      action.undo = { method: "delete.box", args: [box._id] };
      return action;
    }
  move_box: | #js
    async function(userID, action, boxID, pos) {
      const box = this.boxes.find((box) => box._id === boxID);
      const oldPos = box.rect.pos;
      this.$femit("to", "grid.data.list", `${userID}/data/boxes`, "update", [boxID, { rect: { pos } }]);
      action.undo = { method: "move.box", args: [boxID, oldPos] };
      return action;
    }
  resize_box: | #js
    async function(userID, action, boxID, size) {
      const box = this.boxes.find((box) => box._id === boxID);
      const oldSize = box.rect.size;
      this.$femit("to", "grid.data.list", `${userID}/data/boxes`, "update", [boxID, { rect: { size } }]);
      action.undo = { method: "resize.box", args: [boxID, oldSize] };
      return action;
    }
  delete_box: | #js
    async function(userID, action, boxID) {
      this.$femit("to", "grid.data.list", `${userID}/data/boxes`, "delete", [boxID]);
      action.undo = { method: "no.op" };
      return action;
    }
  edit_box: | #js
    async function(userID, action, boxID, newData, oldData) {
      const toValue = (value) => {
        if (value === undefined) return null;
        return value;
      };
      const box = this.boxes.find((box) => box._id === boxID);
      oldData = oldData ||
        Objects.getPropertiesAsTree(box, Objects.getPaths(newData));
      //for (const change of changes) DeepDiff.applyChange(box, change);
      this.$femit("to", "grid.data.list", `${userID}/data/boxes`, "update", [boxID, newData]);
      action.undo = { method: "edit.box", args: [boxID, oldData, newData] };
      return action;
    }
  grid_user_actions_do: | #js
    async function(userID, action, addToStack = true, overwriteRedoActions) {
      action._id = this.nextActionID++;

      if (addToStack && (this.nextRedoAction) && (this.nextRedoAction._id != action._id)) {
        // When deleting the next redo actions from the stack, we're emitting to data.list
        // which we don't know how long it could take (could go to the server)
        // so we're invoking the method again after a timeout
        if (overwriteRedoActions)
        {
          setTimeout(() => {
            this.grid_user_actions_do(userID, action, addToStack);
          }, 100);
          return;
        }
        
        const deleteNextActions = () => {
          const actionIDs = this.userActions
            .slice(this.pointer + 1)
            .map((action) => action._id);

          this.$femit("to", "grid.data.list", `${userID}/user/actions`, "delete", actionIDs);
          setTimeout(() => {
            this.grid_user_actions_do(userID, action, addToStack, true);
          }, 100);
        };

        const askUser = (this.nextRedoActions.length > 5);

        if (!askUser) {
          deleteNextActions();
          return;
        }

        const question = `This will delete ${this.userActions.length - this.pointer - 1} redo actions from the stack:
        ${this.userActions.slice(this.pointer + 1)
          .map((action) => action.redo.method)
          .map((method) => `[${method}]`)
          .join("\n")}
        Are you sure?`
          .replace(/\n/g, "<br/>");

        alertify.confirm(question, deleteNextActions);
        
        return;
      }

      const redo = action.redo;
      const methodName = redo.method.replace(/\./g, "_");
      const method = this[methodName];
      if (!method) {
        const errorMessage = `Method ${methodName} not found on grid.user.action.stack`;
        alertify.error(errorMessage);
        throw new Error(errorMessage);
        return;
      }
      
      action = await method.apply(this, [userID, action, ...redo.args]);

      if (addToStack) {
        this.addToStack(action);
      }

      return action;
    }
  grid_user_actions_undo: | #js
    async function(userID) {
      if (this.pointer < 0) {
        alertify.error("No more actions to undo");
        return;
      }
      const lastAction = this.userActions[this.pointer];
      const undoAction = { redo: lastAction.undo };
      await this.grid_user_actions_do(userID, undoAction, false);
      this.pointer--;
    }
  grid_user_actions_redo: | #js
    async function(userID) {
      if (!this.hasRedoActions)
      {
        alertify.error("No more actions to redo");
        return;
      }
      const nextAction = this.userActions[this.pointer + 1];
      await this.grid_user_actions_do(userID, nextAction, false);
      this.pointer++;
    }
  grid_user_actions_clear: | #js
    function(userID) {
      if (this.userActions.length == 0) return;

      const clearAll = () => {
        this.$femit("to", "grid.data.variable", `${userID}/user/actions/pointer`, "clear", []);
        this.$femit("to", "grid.data.list", `${userID}/user/actions`, "clear", []);
        this.$femit("to", "grid.data.list", `${userID}/data/boxes`, "clear", []);
      }

      alertify.confirm("This will delete all actions from the stack. Are you sure?", clearAll);
    }
  doUntil: | #js
    async function(actionID) {
      if (!actionID) return;
      if (!this.nextAction) return;
      while (this.nextAction && (this.nextAction._id != actionID))
      {
        await this.$nextTick();
        await this.grid_user_actions_redo(this.userID);
      }
      await this.$nextTick();
      await this.grid_user_actions_redo(this.userID);
    }
  addToStack: | #js
    function(action) {
      const userID = this.userID;
      const lastAction = this.userActions[this.pointer];
      if (lastAction && this.isGroupable(action, lastAction)) {
        action = this.groupActions(action, lastAction);
        this.$femit("to", "grid.data.list", `${userID}/user/actions`, "delete", [lastAction._id]);
        this.pointer--;
      }
      this.$femit("to", "grid.data.list", `${userID}/user/actions`, "add", [action]);
      this.pointer++;
    }
  isGroupable: | #js
    function(action, lastAction) {
      if (!lastAction) return false;
      if (action.redo.method != lastAction.redo.method) return false;
      if (["edit.box", "resize.box", "move.box"].includes(action.redo.method))
      {
        // box._id
        if (action.redo.args[0] != lastAction.redo.args[0]) return false;
        if (Object.keys(action.redo.args[1]).join(",") != Object.keys(lastAction.redo.args[1]).join(",")) return false;
        return true;
      }
      return false;
    }
  groupActions: | #js
    function(action, lastAction) {
      action = Objects.clone(action);
      action.undo = Objects.clone(lastAction.undo);
      return action;
    }
computed:
  hasRedoActions: | #js
    function() {
      return (this.nextRedoActions.length > 0);
    }
  lastDoneAction: | #js
    function() {
      return this.userActions[this.pointer];
    }
  nextRedoAction: | #js
    function() {
      return this.nextRedoActions[0];
    }
  nextRedoActions: | #js
    function() {
      return this.userActions.slice(this.pointer + 1);
    }
  nextAction: | #js
    function() {
      return this.nextRedoActions[0];
    }
watch:
  userActions:
    handler: | #js
      async function() {
      }
    deep: true
  pointer:
    handler: | #js
      async function(pointer) {
        this.$femit("to", "grid.data.variable", `${this.userID}/user/actions/pointer`, "set", [pointer])
      }
_:
  examples:
    count: 0
name: grid-user-action-stack
template: >-
  <grid-module class="comp-grid-user-action-stack" icon="ðŸ‘¤ðŸ‘ˆ"
  path="-1764928149."><grid-data-list-view :fuid="userID+'/data/boxes'"
  v-model="boxes" path="-1764928149.0"></grid-data-list-view><div class="flex"
  path="-1764928149.1"><grid-data-list :fuid="userID+'/user/actions'"
  v-model="userActions"
  path="-1764928149.1.0"></grid-data-list><grid-data-variable
  :fuid="userID+'/user/actions/pointer'" :default-value="-1" v-model="pointer"
  path="-1764928149.1.1"></grid-data-variable></div></grid-module>
