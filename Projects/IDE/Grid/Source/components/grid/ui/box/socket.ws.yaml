dom:
  grid.module:
    ':show-title': 'false'
    ref: socket1
    ui.dnd.dropzone:
      @drop-item: onNewLinkDrop
      ui.context.window:
        v-if: '!isNewLinkDragging'
        div: 
          ':style': dataTooltipStyle
          ui.value:
            ':value': socketValue
      ui.dnd.draggable:
        ':show-drag-ghost': 'false'
        ':drag-item': '{ box, direction, socket }'
        @drag-start: onNewLinkDragStart
        @drag-end: onNewLinkDragEnd
        @drag: onNewLinkDrag
        .socket:
          ':class': 'direction + ''-socket'' + '' '' + (isLoading ? ''loading'' : '''')'
          @click: onSocketClick
          div: 
            title: Export socket
            ui.checkbox:
              v-model: socketIsExported
          div: 
            v-if: 'false'
            v-text: '''🔌'''
          div: 
            v-text: getSocketIcon(socket)
          div: 
            class: mx-2
            v-text: socket.name
    ui.leader.line:
      v-if: isNewLinkDragging
      ref: leaderLine1
      ':from': socketEl
      ':to': targetPlugEl
      line-path: fluid
      color: '#404040'
    div:
      v-show: isNewLinkDragging
      ref: targetPlug1
      ':style': targetPlugStyle
      ui.value.preview:
        ':value': socketValue
props:
  box: null
  socket: null
  direction: null
data:
  socketEl: null
  targetPlugEl: null
  targetPlugPos: null
  isNewLinkDragging: false
  ghostBox: null
  newBox: null
  socketIsExported: null
  socketAlertValue: null
  isLoading: 0
  socketValue: null
mounted: | #js
  function() {
    this.socketEl = this.$refs.socket1.$el;

    this.$root.els = this.$root.els || {};
    this.$root.els[this.socketElPath] = this.$el;

    this.ghostBox = {
      _id: `${this.box._id}/${this.socket.name}/ghost/box`,
      type: null,
      name: null,
      rect: {
        pos: { x: 150, y: -100 },
        size: { width: 300, height: 200 },
        is: {
          minimized: true,
        }
      },
      sockets: {
        input: [ ],
        output: [ ],
      },
    };
  }
unmounted: | #js
  function() {
    delete this.$root.els[this.socketElPath];
  }
methods:
  init: | #js
    function(socket){
      this.socketIsExported = socket.is?.exported;
      this.socketValue = this.getSocketValue();
    }
  onSocketClick: | #js
    function() {
      console.log(this.socketValue);
      alertify.message(`Socket value logged to console.`);
    }
  grid_client_runtime_socket_value_change: | #js
    function(boxID, sDirection, sID, sValue) {
      // #TODO: Slow
      if (boxID != this.box._id) return;
      if (sDirection != this.direction) return;
      if (sID != this.socket._id) return;
      this.socketValue = sValue;
      this.isLoading++;
      setTimeout(() => {
        this.isLoading--;
      }, 400);
    }
  grid_user_action_stack_new_box_created: | #js
    function(box) {
      this.newBox = box;
    }
  getSocketValue: | #js
    function() {
      const socketData = this.$root.socket?.runtime.data[this.box._id];
      if (!socketData) return null;
      const socketValue = socketData[this.direction][this.socket._id];
      return socketValue;
    }
  onNewLinkDragStart: | #js
    async function(e) {
      this.targetPlugEl = this.$refs.targetPlug1;
      setTimeout(() => {
        this.isNewLinkDragging = true;
      }, 200);
    }
  onNewLinkDrag: | #js
    function(e) {
      const pos = { x: e.e.clientX, y: e.e.clientY };
      if (pos.x == 0 && pos.y == 0) return;
      //const pos = e.relative.pos;
      this.targetPlugPos = { x: (pos.x - 20), y: (pos.y - 20) };
    }
  onNewLinkDragEnd: | #js
    function(e) {
      this.isNewLinkDragging = false;
      this.targetPlugPos = null;
      this.targetPlugEl = null;
    }
  onNewLinkDrop: | #js
    function(linkSource) {
      if (linkSource.direction == this.direction) {
        alertify.error('You must connect an output socket to an input socket.');
        return;
      }

      const isReversed = (linkSource.direction == 'input');

      const fromBox = isReversed ? this.box : linkSource.box;
      const toBox = isReversed ? linkSource.box : this.box;
      const fromSocket = isReversed ? this.socket : linkSource.socket;
      const toSocket = isReversed ? linkSource.socket : this.socket;

      const from = {
        box: { _id: fromBox._id },
        socket: { _id: fromSocket._id, type: fromSocket.type },
      };
      const to = {
        box: { _id: toBox._id },
        socket: { _id: toSocket._id, type: toSocket.type },
      };

      const gridUiBoxVue = this.$root.vm.getAncestors(this, "grid.ui.box")[0];
      gridUiBoxVue.$femit('create.link', from, to);
    }
  grid_client_surface_drop_item: | #js
    async function(dragItem) {
      if (!this.isNewLinkDragging) return;

      // Didn't drop on the surface
      if (!this.targetPlugPos) return;

      this.isNewLinkDragging = false;

      const newBox = this.getNewBox(this.ghostBox);
     
      // Create the box
      this.$femit("create.box", newBox);

      // Wait for the box to be created
      this.newBox = null;
      await this.$root.wait(() => this.newBox);

      // Link this socket to the new box
      this.onNewLinkDrop({ box: this.newBox, socket: this.newBox.sockets.input[0], direction: 'input' });
    }
  getSocketIcon: | #js
    function(socket) {
      return {
        data: '🧊',
        iterator: '🔗🖇️',
        view: '⬜',
        event: '⚡',
      }[socket?.type];
    }
  getSurfaceElement: | #js
    function() {
      const gridUiBoxVue = this.$root.vm.getAncestors(this, "grid.ui.box")[0];
      return gridUiBoxVue.surfaceElement;
    }
  getNewBox: | #js
    function(ghostBox) {
      const surfaceElement = this.getSurfaceElement();
      const surfaceRect = this.$root.getAbsoluteRect(surfaceElement);
      
      const newBox = Objects.clone(ghostBox);
      delete newBox._id;

      newBox.sockets.input.add({ _id: 1, type: "data", name: "" });

      const { x, y } = this.targetPlugPos;
      let pos = { x, y };
      // Translate targetPlugPos, which is relative to the window, to be relative to the surface
      pos = { x: (x - surfaceRect.left), y: (y - surfaceRect.top) };
      // Box coordinates are relative to the center of the surface
      pos = { x: (pos.x - (surfaceRect.width / 2)), y: ((surfaceRect.height / 2) - pos.y) };
      // Box coordinates mark the center of the box, not the top-left corner
      pos = { x: (pos.x + (newBox.rect.size.width / 2)), y: (pos.y - (newBox.rect.size.height / 2)) };

      newBox.rect.pos = pos;

      return newBox;
    }
  getBoxVue: | #js
    function() {
      return this.$root.vm.getAncestors(this, "grid.ui.box")[0];
    }
computed:
  dataTooltipStyle: | #js
    function() {
      const style = {};
      style["max-width"] = "20em";
      style["max-height"] = "10em";
      style.overflow = "hidden";
      style["pointer-events"] = "none";
      return style;
    }
  showGhostBox: | #js
    function() {
      return false;
      return this.isNewLinkDragging;
    }
  socketElPath: | #js
    function() {
      return `/box/${this.box._id}/sockets/${this.direction}/${this.socket._id}`;
    }
  targetPlugStyle: | #js
    function() {
      if (!this.targetPlugPos) return null;
      const baseEl = this.$root.getAbsoluteRect(this.$el);
      const targetPlug = this.$refs.targetPlug1.getBoundingClientRect();
      const x = (this.targetPlugPos.x - baseEl.left + baseEl.width + targetPlug.width);
      const y = (this.targetPlugPos.y - baseEl.top - targetPlug.height);
      const style = {
        position: 'fixed',
        left: `${(x - 140)}px`,
        top: `${(y + 20)}px`,
        border: `3px solid red`
      };
      style.background = "linear-gradient(to right, #303030, #101010)";
      style.border = "1px solid #ffffff30";
      style.width = "fit-content";
      style.height = "fit-content";
      style.padding = "0.5em";
      style.whiteSpace = "nowrap";
      return style;
    }
watch:
  socket:
    handler: | #js
      function(socket) {
        this.init(socket);
      }
    immediate: true
  socketIsExported: | #js
    function(socketIsExported) {
      if (socketIsExported == undefined) return;
      if (socketIsExported == this.socket.is?.exported) return;
      this.$femit("edit.socket", this.box._id, this.direction, this.socket._id, { is: { exported: socketIsExported } });
    }
style:
  .socket-alert-value-box:
    max-width: 10em
    max-height: 10em
    overflow: hidden
  .socket:
    font-size: 100%
    opacity: 0.4
  .socket:hover:
    opacity: 1
  .socket.loading:
    border: 1px solid yellow
  .input-socket, .output-socket:
    display: flex
    cursor: grab
  .output-socket:
    flex-direction: row-reverse
_:
  examples:
    count: 0
name: grid-ui-box-socket
template: >-
  <grid-module class="comp-grid-ui-box-socket" :show-title="false" ref="socket1"
  path="-321995800."><ui-dnd-dropzone @drop-item="onNewLinkDrop"
  path="-321995800.0"><ui-context-window v-if="!isNewLinkDragging"
  path="-321995800.0.0"><div :style="dataTooltipStyle"
  path="-321995800.0.0.0"><ui-value :value="socketValue"
  path="-321995800.0.0.0.0"></ui-value></div></ui-context-window><ui-dnd-draggable
  :show-drag-ghost="false" :drag-item="{ box, direction, socket }"
  @drag-start="onNewLinkDragStart" @drag-end="onNewLinkDragEnd"
  @drag="onNewLinkDrag" path="-321995800.0.1"><div class="socket"
  :class="direction + '-socket' + ' ' + (isLoading ? 'loading' : '')"
  @click="onSocketClick" path="-321995800.0.1.0"><div title="Export socket"
  path="-321995800.0.1.0.0"><ui-checkbox v-model="socketIsExported"
  path="-321995800.0.1.0.0.0"></ui-checkbox></div><div v-if="false"
  v-text="'🔌'" path="-321995800.0.1.0.1"></div><div
  v-text="getSocketIcon(socket)" path="-321995800.0.1.0.2"></div><div
  class="mx-2" v-text="socket.name"
  path="-321995800.0.1.0.3"></div></div></ui-dnd-draggable></ui-dnd-dropzone><ui-leader-line
  v-if="isNewLinkDragging" ref="leaderLine1" :from="socketEl" :to="targetPlugEl"
  line-path="fluid" color="#404040" path="-321995800.1"></ui-leader-line><div
  v-show="isNewLinkDragging" ref="targetPlug1" :style="targetPlugStyle"
  path="-321995800.2"><ui-value-preview :value="socketValue"
  path="-321995800.2.0"></ui-value-preview></div></grid-module>
