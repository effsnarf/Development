dom:
  grid.module:
    icon: ðŸ“¦
    ':show-title': 'false'
    ui.window:
      v-if: showBoxWindow
      ref: window1
      ':css-class': windowCssClass
      ':window-style': windowStyle
      ':rect': boxRect
      ':surface-element': surfaceElement
      ':surface-scale': surfaceScale
      ':center-coords': 'true'
      ':show-header': '!!box.type'
      @is-hovered: onWindowHovered
      @is-minimized: onToggleMinimized
      @drag-stop: onDragStop
      @click: onBoxWindowClick
      template: 
        v-slot: above
        grid.ui.box.sockets: 
          ':box': box
          direction: input
      template: 
        v-slot: header
        .flex:
          grid.ui.box.header:
            v-if: box.type
            ref: header1
            class: flex-grow-1
            ':box': box
            ':box-icon': boxIcon
            @title-icon-click: onTitleIconClick
      template: 
        v-slot: content
        .h-100pc:
          component: 
            ref: boxComp1
            v-if: box.type
            class: h-100pc
            ':is': getBoxCompName(box)
            ':userID': userID
            ':box': box
          grid.ui.box.type.picker:
            v-if: '!box.type'
            ':box': box
      template: 
        v-slot: below
        grid.ui.box.sockets: 
          ':box': box
          direction: output
        div:
          transition.group:
            name: list
            .alert:
              v-for: alert in alerts
              ':key': alert._id
              @click: deleteAlert(alert._id)
              component: 
                ':is': alert.comp
                v-bind: alert.props
        .error:
          v-if: error
          h3:
            v-text: error.message
props:
  userID: null
  box: null
  surfaceElement: null
data:
  boxIcon: null
  oldBox: null
  error: null
  boxIsLoading: 0
  surfaceScale: 1
  boxRect: null
  showSockets: 0
  alerts: []
  nextAlertID: 1
mounted: | #js
  async function() {
    await this.$nextTick();
    await this.$root.wait(() => this.$refs.window1?.$refs.window);
    this.$root.els[`/box/window/${this.box._id}`] = this.$refs.window1.$refs.window;
  }
unmounted: | #js
  function() {
    delete this.$root.els[`/box/window/${this.box._id}`];
  }
methods:
  onWindowHovered: | #js
    function(isHovered) {
      this.$femit("hovered", this.box, isHovered);
    }
  onTitleIconClick: | #js
    function() {
      this.$femit("execute", this.box._id);
    }
  grid_client_runtime_socket_value_change: | #js
    function(boxID, sDirection, sID, sValue) {
      if (boxID != this.box._id) return;
      // When a socket value changes, we want to flash the sockets
      this.showSockets++;
      setTimeout(() => {
        this.showSockets--;
      }, 2000);
    }
  grid_client_runtime_func_result_change: | #js
    function(boxID, resultValue) {
      if (boxID != this.box._id) return;
      this.deleteAlert(a => (a.props.type == 'func.result'));
      this.addAlert('ui-value-any', { type: 'func.result', value: resultValue });
    }
  grid_ui_box_socket_value_change: | #js
    async function(boxID, socketDirection, sID, socketValue) {
      if (boxID != this.box._id) return;
      this.boxIsLoading++;
      await this.$root.wait(600);
      this.boxIsLoading--;
    }
  grid_client_runtime_box_is_loading: | #js
    function(boxID, isLoading) {
      const boxComp1 = this.$refs.boxComp1;
      if (boxComp1?.onBoxIsLoading) boxComp1.onBoxIsLoading(boxID, isLoading);
      if (boxID != this.box._id) return;
      this.boxIsLoading += (isLoading ? 1 : -1);
      if (this.$refs.header1) this.$refs.header1.boxIsLoading = this.boxIsLoading;
    }
  grid_client_runtime_box_error: | #js
    function(boxID, error) {
      if (boxID != this.box._id) return;
      this.error = error;
    }
  grid_client_workspace_surface_scale: | #js
    function(scale) {
      this.surfaceScale = scale;
    }
  addAlert: | #js
    function(comp, props) {
      const _id = this.nextAlertID++;
      this.alerts.push({ _id, comp, props });
      setTimeout(() => {
        this.deleteAlert(_id);
      }, 3000);
    }
  deleteAlert: | #js
    function(cond) {
      if (typeof cond == "number") {
        const _id = cond;
        cond = ((a) => a._id == _id);
      }
      this.alerts.removeBy(cond);
    }
  getBoxTitle: | #js
    function(box) {
      return box.type;
    }
  getBoxCompName: | #js
    function(box) {
      if (!box?.type) return null;
      return `grid.ui.box.${box.type}`.replace(/\./g, "-");
    }
  onToggleMinimized: | #js
    function(isMinimized) {
      this.$femit("edit.box", this.box._id, { rect: { is: { minimized: isMinimized } } });
    }
  onDragStop: | #js
    function(rect, dragType) {
      if (dragType === "resize")
      {
        this.$femit("resize.box", this.box._id, rect.size);
      }
      else
      {
        this.$femit("move.box", this.box._id, rect.pos);
      }
    }
  getGradientBackground: | #js
    function(hexColor, opacity) {
      let r = parseInt(hexColor.substring(1, 3), 16);
      let g = parseInt(hexColor.substring(3, 5), 16);
      let b = parseInt(hexColor.substring(5, 7), 16);

      let darkColor = `rgba(${Math.floor(r * 0.8)}, ${Math.floor(g * 0.8)}, ${Math.floor(b * 0.8)}, ${opacity * 0.8})`;
      let lightColor = `rgba(${Math.floor(r * 0.9)}, ${Math.floor(g * 0.9)}, ${Math.floor(b * 0.9)}, ${opacity * 0.9})`;

      return `linear-gradient(to right, ${darkColor}, ${lightColor})`;
    }
  getBoxRect: | #js
    async function(box) {
      if (!box) return null;
      let rect = Objects.clone(box.rect);
      if (box.rect.is.grouped) {
        const groupBox = this.$root.boxes.find(b => b._id == box.groupBoxID);
        if (!groupBox) {
          await this.$root.wait(100);
          return await this.getBoxRect(box);
        }
        rect = Objects.clone(groupBox.rect);
        rect.opacity = 0;
      }
      if (!("opacity" in rect)) rect.opacity = (box.rect.is.visible ? 1 : 0);
      return rect;
    }
  onBoxWindowClick: | #js
    function() {
    }
  testMethod: | #js
    function(again = 1000) {
      if (again == 1000) alertify.message(`testMethod ${again}`);
      if (again > 0) {
        setTimeout(() => {
          this.testMethod(again - 1);
        }, 1);
      }
    }
  yamlify: | #js
    function(obj) {
      return jsyaml.dump(obj);
    }
computed:
  showBoxWindow: | #js
    function() {
      return this.box.rect.is.visible;
    }
  windowCssClass: | #js
    function() {
      const cls = {};
      if (this.showSockets) cls["hovered"] = true;
      if (this.box.is?.selected) cls["selected"] = true;
      return cls;
    }
  windowStyle: | #js
    function() {
      const style = {};
      if (this.boxIsLoading) style.border = `2px solid yellow`;
      if (this.error) style.border = `4px solid red`;
      if (this.$root.boxTypeColors) style.background = this.getGradientBackground(this.$root.boxTypeColors[this.box.type || this.box.type?.split('.')[0]] || "#000000", 0.2);
      return style;
    }
watch:
  box:
    handler: | #js
      async function(box) {
        this.boxRect = await this.getBoxRect(box);
      }
    immediate: true
    deep: true
_:
  examples:
    count: 0
style:
  .comp-ui-window.selected:
    border: 4px dashed yellow
  .comp-ui-window.selected .window:
    filter: grayscale(1)
  .alert:
    width: 100%
    max-height: 10em
    overflow: hidden
  .func-box-result:
    max-height: 10em
    overflow: auto
    opacity: 0.5
  .sockets:
    z-index: 10
  .sockets:hover: null
  .above .sockets, .below .sockets:
    position: absolute
    width: 100%
    margin: auto
    opacity: 0
    transition: 0.4s
  .above .sockets:
    transform: translate(0em, 100%)
    transform-origin: 0 top
  .below .sockets:
    transform: translate(0em, -200%)
  .hovered .above .sockets, .hovered .below .sockets:
    opacity: 1
  .hovered .above .sockets:
    transform: translate(1.5em, -100%) !important
  .hovered .below .sockets:
    transform: translate(-1.5em, 0)
  .header:
    font-size: 120%
  .comp-grid-module .module-content:
    height: 100%
  .error:
    position: absolute
    top: 0
    width: 100%
  .box2:
    margin: 0
    border: none
name: grid-ui-box
template: >-
  <grid-module class="comp-grid-ui-box" icon="ðŸ“¦" :show-title="false"
  path="1671629593."><ui-window v-if="showBoxWindow" ref="window1"
  :css-class="windowCssClass" :window-style="windowStyle" :rect="boxRect"
  :surface-element="surfaceElement" :surface-scale="surfaceScale"
  :center-coords="true" :show-header="!!box.type" @is-hovered="onWindowHovered"
  @is-minimized="onToggleMinimized" @drag-stop="onDragStop"
  @click="onBoxWindowClick" path="1671629593.0"><template v-slot:above
  path="1671629593.0.0"><grid-ui-box-sockets :box="box" direction="input"
  path="1671629593.0.0.0"></grid-ui-box-sockets></template><template
  v-slot:header path="1671629593.0.1"><div class="flex"
  path="1671629593.0.1.0"><grid-ui-box-header class="flex-grow-1"
  v-if="box.type" ref="header1" :box="box" :box-icon="boxIcon"
  @title-icon-click="onTitleIconClick"
  path="1671629593.0.1.0.0"></grid-ui-box-header></div></template><template
  v-slot:content path="1671629593.0.2"><div class="h-100pc"
  path="1671629593.0.2.0"><component class="h-100pc" ref="boxComp1"
  v-if="box.type" :is="getBoxCompName(box)" :userID="userID" :box="box"
  path="1671629593.0.2.0.0"></component><grid-ui-box-type-picker
  v-if="!box.type" :box="box"
  path="1671629593.0.2.0.1"></grid-ui-box-type-picker></div></template><template
  v-slot:below path="1671629593.0.3"><grid-ui-box-sockets :box="box"
  direction="output" path="1671629593.0.3.0"></grid-ui-box-sockets><div
  path="1671629593.0.3.1"><transition-group name="list"
  path="1671629593.0.3.1.0"><div class="alert" v-for="alert in alerts"
  :key="alert._id" @click="deleteAlert(alert._id)"
  path="1671629593.0.3.1.0.0"><component :is="alert.comp" v-bind="alert.props"
  path="1671629593.0.3.1.0.0.0"></component></div></transition-group></div><div
  class="error" v-if="error" path="1671629593.0.3.2"><h3 v-text="error.message"
  path="1671629593.0.3.2.0"></h3></div></template></ui-window></grid-module>
