dom:
  div:
    ui.linq.evaluator:
      ref: linqEval1

props:
  node:
  nodeVar:
  nodeVarPath:
  dataItem:

data:
  _items:
  items:
  inited:
    linq:
  live:
    url: null
  error:

mounted: | #js
  function() {
    this.init();
    this.$root.e.on("app.node.changed", this.onAppNodeChanged.bind(this));
    this.$root.e.on("app.state.changed", this.onAppStateChanged.bind(this));
  }

methods:
  refresh: | #js
    async function() {
      try {
        this.$emit("error", null);
        const varPath = this.nodeVar.path.join('.');
        const getNewUrl = this.$root.toContextFunc(this, null, { args: [], code: `return ${this.nodeVar.url};` }, { async: false });
        const oldUrl = this.$root.studio.user.app.state.get(`${varPath}._url`);
        const newUrl = getNewUrl();
        const oldLinq = this.$root.studio.user.app.state.get(`${varPath}._linq`);
        const newLinq = this.nodeVar.linq;
        let linqItems = false;

        // if the url has changed
        if (newUrl != oldUrl) {
          this.$root.studio.user.app.state.set(`${varPath}._url`, newUrl);
          this._items = (await this.$root.fetchFromUrl(newUrl));
          this.$root.studio.user.app.state.set(`${varPath}._items`, this._items);
          linqItems = true;
        }
        else
        {
          this._items = this.$root.studio.user.app.state.get(`${varPath}._items`);
        }
        // if the linq has changed
        if (!Objects.areEqual(newLinq, oldLinq)) {
          this.$root.studio.user.app.state.set(`${varPath}._linq`, newLinq);
          linqItems = true;
        }
        if (linqItems) {
          this.items = await this.linqEval(this._items, newLinq);
          this.$root.studio.user.app.state.set(`${varPath}.items`, this.items);
        }
        this.items = this.$root.studio.user.app.state.get(`${varPath}.items`);
        this.$emit("update", this.items);
      }
      catch (ex) {
        this.$emit("error", ex.message);
      }
    }
  init: | #js
    function() {
      this.refresh();
    }
  onAppStateChanged: | #js
    function(vars) {
      this.refresh();
    }
  onAppNodeChanged: | #js
    function(node) {
      if (node.id != this.node.id) return;
      this.refresh();
    }
  linqEval: | #js
    async function(inputData, linq, attempt = 0) {
      const linqEval1 = this.getLinqEvaluator();
      if (!linqEval1) {
        if (attempt > 20) {
          alertify.error("Linq evaluator not found.");
          return;
        }
        await this.$nextTick();
        await (0.1).seconds().wait();
        return await this.linqEval(inputData, linq, (attempt + 1));
      }
      this.ticker1?.stop();
      this.ticker1 = null;
      linq = (linq ?? []);
      const datas = linqEval1.evaluateOps(null, inputData, linq);
      const outputData = datas.last();
      return outputData;
    }
  getLinqEvaluator: | #js
    function() {
      return this.$children.find(c => c.$options.name == "ui-linq-evaluator");
    }

watch:
  items:
    immediate: true
    deep: false
    handler: | #js
      function(items) {
        this.$emit("update", items);
      }
  nodeVar:
    immediate: true
    handler: | #js
      function(nodeVar) {
        this.init(nodeVar);
      }
