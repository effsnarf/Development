dom:
  div:
    v-if: "true"
    ui.linq.evaluator:
      ref: linqEval1

props:
  node:
  nodeVar:
  nodeVarPath:

data:
  _url:
  _items: []
  items: []
  inited:
    url:
    linq:
  live:
    url: null

mounted: | #js
  function() {
    this.init();
    this.$root.e.on("app.node.changed", this.onAppNodeChanged.bind(this));
  }

methods:
  onAppNodeChanged: | #js
    function(node) {
      if (node.id != this.node.id) return;
      const nodeVar = this.nodeVar;
      // if the url has changed
      if (nodeVar.url != this.inited.url) {
        // stop the previous watcher
        this.live.url?.destroy();
        this.live.url = this.$root.liveNodeVar(this, nodeVar, "_url", nodeVar.url, async (newUrl) => {
          this.$data._items = (await this.$root.fetchFromUrl(newUrl));
          this.items = this.linqEval(this.$data._items);
        });
        this.inited.url = nodeVar.url;
      }
      // if the linq has changed
      if (nodeVar.linq != this.inited.linq) {
        this.items = this.linqEval(this.$data._items)
        this.inited.linq = nodeVar.linq;
      }
    }
  init: | #js
    function() {
      this.$root.bindToUserAppState(this, "_items", `${this.nodeVarPath}.${this.nodeVar.name}._value`);
      this.$root.bindToUserAppState(this, "items", `${this.nodeVarPath}.${this.nodeVar.name}.value`);
      this.onAppNodeChanged(this.node);
    }
  linqEval: | #js
    function(inputData) {
      if (!this.$refs.linqEval1) return null;
      const linq = (this.nodeVar.linq ?? []);
      const datas = this.$refs.linqEval1.evaluateOps(null, inputData, linq);
      const outputData = datas.last();
      return outputData;
    }

watch:
  items:
    immediate: true
    deep: false
    handler: | #js
      function(value) {
        this.$emit("update", value);
      }
  nodeVar:
    immediate: true
    handler: | #js
      function(nodeVar) {
        this.init(nodeVar);
      }
