dom:
  div:
    v-if: "true"
    ui.linq.evaluator:
      ref: linqEval1

props:
  node:
  nodeVar:
  nodeVarPath:

data:
  inited:
    linq:
  live:
    url: null
  error:

mounted: | #js
  function() {
    this.init();
    this.$root.e.on("app.node.changed", this.onAppNodeChanged.bind(this));
    this.$root.e.on("app.state.changed", this.onAppStateChanged.bind(this));
  }

methods:
  refresh: | #js
    async function() {
      try {
        this.error = null;
        const varPath = this.nodeVar.path.join('.');
        const getNewUrl = this.$root.toContextFunc(this, null, { args: [], code: `return ${this.nodeVar.url};` }, { async: false });
        const oldUrl = this.$root.studio.user.app.state.get(`${varPath}._url`);
        const newUrl = getNewUrl();
        const oldLinq = this.$root.studio.user.app.state.get(`${varPath}._linq`);
        const newLinq = this.nodeVar.linq;
        let _items = [];
        let items = [];
        let linqItems = false;
        // if the url has changed
        if (newUrl != oldUrl) {
          this.$root.studio.user.app.state.set(`${varPath}._url`, newUrl);
          _items = (await this.$root.fetchFromUrl(newUrl));
          this.$root.studio.user.app.state.set(`${varPath}._items`, _items);
          linqItems = true;
        }
        else
        {
          _items = this.$root.studio.user.app.state.get(`${varPath}._items`);
        }
        // if the linq has changed
        if (!Objects.areEqual(newLinq, oldLinq)) {
          this.$root.studio.user.app.state.set(`${varPath}._linq`, newLinq);
          linqItems = true;
        }
        if (linqItems) {
          items = this.linqEval(_items, newLinq);
          this.$root.studio.user.app.state.set(`${varPath}.items`, items);
        }
        items = this.$root.studio.user.app.state.get(`${varPath}.items`);
        this.$emit("update", items);
      }
      catch (ex) {
        this.$root.e.emit("user.app.error", this, ex.message);
      }
    }
  init: | #js
    function() {
      this.refresh();
    }
  onAppStateChanged: | #js
    function(vars) {
      const var1 = vars.find(v => (this.nodeVarPath == v.varPath.join(".")));
      if (!var1) return;
      this.refresh();
    }
  onAppNodeChanged: | #js
    function(node) {
      if (node.id != this.node.id) return;
      this.refresh();
    }
  linqEval: | #js
    function(inputData, linq) {
      if (!this.$refs.linqEval1) return null;
      linq = (linq ?? []);
      const datas = this.$refs.linqEval1.evaluateOps(null, inputData, linq);
      const outputData = datas.last();
      return outputData;
    }

watch:
  items:
    immediate: true
    deep: false
    handler: | #js
      function(items) {
        this.$emit("update", items);
      }
  nodeVar:
    immediate: true
    handler: | #js
      function(nodeVar) {
        this.init(nodeVar);
      }
