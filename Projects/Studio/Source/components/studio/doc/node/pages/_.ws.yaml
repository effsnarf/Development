dom:
  div:
    .pages:
      .page:
        v-for: pageNode in visiblePageNodes
        :class: pageClasses[pageNode.id]
        :key: pageNode.id
        ui.anim:
          :anim: pageTransAnim
          :anim-state: pageStates[pageNode.id]
          studio.doc.node:
            :node: pageNode
            :user-app-state: userAppState
            :sui: sui
            :key: pageNode.id

props:
  node:
  userAppState:
  sui:

data:
  pageStates: {}
  pageClasses: {}
  visiblePageNodes: []
  pageTransAnim:
    name: fade
    enter:
      from:
        opacity: 0
    leave:
      to:
        opacity: 1

mounted: | #js
  function() {
    this.$watch("sui.page.selected", this.onSelectedPageChanged.bind(this));
  }

methods:
  onSelectedPageChanged: | #js
    async function(newPage, oldPage) {
      this.clearPageStates();
      if (oldPage) this.pageStates[oldPage.id] = "leaving";
      this.refresh();
      if (oldPage) await (0.5).seconds().wait();
      this.pageStates[newPage.id] = "entering";
      this.refresh();
    }
  refreshVisiblePageNodes: | #js
    function() {
      this.visiblePageNodes = this.pageNodes.filter(pageNode => (!!this.pageStates[pageNode.id]));
    }
  clearPageStates: | #js
    function() {
      for (const key in this.pageStates) this.pageStates[key] = null;
    }
  updatePageClasses: | #js
    function() {
      for (const pageNodeID in this.pageStates) {
        this.pageClasses[pageNodeID] = this.getPageClass(pageNodeID);
      }
    }
  getPageClass: | #js
    function(pageNodeID) {
      const cls = {};
      cls.active = ("entering" == this.pageStates[pageNodeID]);
      return cls;
    }
  refresh: | #js
    function() {
      this.updatePageClasses();
      this.refreshVisiblePageNodes();
    }

computed:
  pageNodes: | #js
    function() {
      return [...this.node.children];
    }

watch:

style:
  .pages:
    min-height: 100vh
  .page:
    position: absolute
    width: 100%
    opacity: 0.7
    pointer-events: none
  .page.active:
    pointer-events: auto
