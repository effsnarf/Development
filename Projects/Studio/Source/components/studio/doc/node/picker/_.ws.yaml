dom:
  div:
    ui.mouse:
      @hovered-element: onHoveredElement
      ':global': true
    ui.context.window:
      ref: context1
      :global: true
      @pinned: onContextPinned
      div:
        .flex:
          transition:
            name: slide
            :key: sui.node.active?.id
            div:
              :style: "{ 'max-height': '6em', overflow: 'hidden' }"
              .flex:
                studio.doc.node:
                  :node: contextNode
                  :sui: sui
                studio.dom.tree.node:
                  v-if: "false"
                  :item: contextNode
                  :sui: sui
        .flex:
          ui.drawer:
            direction: "horizontal"
            :open: "!$refs.context1?.isPinned"
            .tree-indent:
              div:
                v-for: (cnode, i) in hovered.cnodes
                studio.dom.tree.node:
                  :item: cnode.node
                  :sui: sui
                  @click: () => refreshParentNodes(cnode)
              div:
                studio.dom.tree.node:
                  v-for: child in hovered.nodes[hovered.nodes.length-1]?.children
                  :item: child
                  :sui: sui
                  :key: child.id
          div:
            studio.doc.node.editor:
              :node: contextNode
              :sui: sui
              :is-tabs-drawer-open: "$refs.context1?.isPinned"
              @dom-edit: (...args) => $emit('dom-edit', ...args)
props:
  userApp:
  sui:

data:
  hovered:
    element:
    vue:
    node:
    nodes: []
    cnodes: []

mounted: | #js
  function() {
    this.$watch("sui.node.selected", this.onSelectedNodeChanged.bind(this));
  }

methods:
  onSelectedNodeChanged: | #js
    async function(newNode) {
      //await this.refreshParentNodes(newNode);
    }
  onContextPinned: | #js
    function(isPinned) {
      this.sui.node.selected = (!isPinned ? false : this.sui.node.hovered);
    }
  refreshNodeTree: | #js
    async function() {
      const vue = this.hovered.vue?.();
      this.hovered.node = this.getDomNodeFromVue(vue);
      this.sui.node.hovered = this.hovered.node;
      await this.refreshParentNodes({ node: this.hovered.node, element: this.hovered.element });
    }
  refreshParentNodes: | #js
    async function(cnode) {
      this.hovered.cnodes = await this.getCNodeAncestors(cnode);
      this.hovered.nodes = this.hovered.cnodes.map(cn => cn.node);
      this.sui.nodes.hovered = this.hovered.nodes;
    }
  onHoveredElement: | #js
    async function(el) {
      if (this.$refs.context1?.isPinned) return;
      this.hovered.element = el;
      const vue = this.getVueFromElement(el);
      this.hovered.vue = (!vue ? null : () => vue);
      await this.refreshNodeTree();
    }
  getCNodeAncestors: | #js
    async function(cnode) {
      //if (cnode?.node?.type == "image") debugger;
      if (!cnode?.node || !cnode?.element) return [];
      const cnodes = [];
      cnodes.unshift(cnode);
      while ((cnodes.length < 5) && (cnode = await this.getCNodeParent(cnode))) cnodes.unshift(cnode);
      return cnodes;
    }
  getCNodeParent: | #js
    async function(cnode) {
      if (!cnode?.node || !cnode?.element) return null;
      let cparent;
      let tryAgain = false;
      let tryCount = 0;
      let parentVue = this.getVueFromElement(cnode.element)?.$parent;
      //if (!parentVue) return null;
      do
      {
        cparent = this.getCNodeFromVue(parentVue);
        tryAgain = false;
        if (cparent) {
          if (cparent.node.id == cnode.node.id) {
            parentVue = parentVue.$parent;
            tryAgain = true;
          }
        }
        tryCount++;
      }
      while (tryAgain && (tryCount < 10) && parentVue);
      return cparent;
    }
  getCNodeFromVue: | #js
    function(vue) {
      const node = this.getDomNodeFromVue(vue);
      if (!node) return null;
      return { node, element: vue.$el };
    }
  getCNodeFromElement: | #js
    function(el) {
      const vue = this.getVueFromElement(el);
      const node = this.getDomNodeFromVue(vue);
      return { node, element: vue.$el };
    }
  getDomNodeFromVue: | #js
    function(vue) {
      if (!vue) return null;
      if (vue.node) return vue.node;
      return this.getDomNodeFromVue(vue.$parent);
    }
  getVueFromElement: | #js
    function(el) {
      const vue = this.getVueFromVnode(this.getVnodeFromElement(el));
      return vue;
    }
  getVnodeFromElement: | #js
    function(el) {
      if (!el) return null;
      if (el.__vue__) return el.__vue__;
      return this.getVnodeFromElement(el.parentElement);
    }
  getVueFromVnode: | #js
    // Skip vnodes like <keep-alive>, <transition>, etc.
    function(vnode) {
      if (!vnode) return null;
      if (this.vNodeIsVue(vnode)) return vnode;
      return this.getVueFromVnode(vnode.$parent);
    }
  vNodeIsVue: | #js
    function(vnode) {
      if ([`transition`, `transition-group`, `keep-alive`].includes(vnode.$options._componentTag)) return false;
      return true;
    }

computed:
  contextNode: | #js
    function() {
      if (this.$refs.context1?.isPinned) return this.sui.node.active;
      return this.sui.node.hovered;
    }

style:
