dom:
  div:
    :key: key1
    ui.input.layout:
      :layout-types: layoutTypes
      :value: node.layout
      @preview: onPreview
      @input: onInput

props:
  node:
  initial:
  sui:

data:
  key1: 1

mounted: | #js
  function() {
    this.$root.e.on("app.node.changed", this.onAppNodeChanged.bind(this));
  }

methods:
  onAppNodeChanged: | #js
    function(node) {
      if (node.id != this.node.id) return;
      this.refresh();
    }
  onPreview: | #js
    function(layout) {
      this.node.layout = layout;
      this.$root.e.emit("app.node.changed", this.node);
    }
  onInput: | #js
    function(layout) {
      // because of preview, [node] already has the new layout
      const oldNode = Objects.clone(this.initial.node);
      const newNode = Objects.clone(this.node);
      this.$root.do("edit.node", { oldNode, newNode });
      this.initial.node.layout = Objects.clone(layout);
      this.refresh();
    }
  refresh: | #js
    function() {
      this.key1++;
    }

computed:
  layoutTypes: | #js
    function() {
      switch (this.node.type) {
        case "panel": return null;
        case "list": return ["grid.y", "grid.x", "grid.uniform"];
      }
      alertify.warning(`${this.node.type} layout types not implemented`);
      return null;
    }
