dom:
  div:
    ui.input.exp:
      :context: nodeContext
      :data-items: sui?.selected.dataItems
      :eval-exp-item: evalExpItem.bind(this)
      :value: initial.url
      :error: error
      @input: onInput
    div:
      studio.app.runtime.state.branch:
        :node: node
        :node-var-path: nodeVarPath
        :user-app-state: userAppState
        :field-names: "{ _url: '🌐 url', _items: '🌐🧊 fetched data', items: '🔎🧊 linqd data' }"
        template:
          v-slot: after__url
          div:
            v-if: (nodeVarData?._items)
            h3:
              title: The fetched data can be transformed using a LINQ expression.
              v-text: "'🧊🔎 linq'"
            ui.linq:
              :style: "{ margin: 'auto' }"
              :input: nodeVarData._items
              :value: initial.linq
              @input: setLinq
              @output: (value) => nodeVarLinqedData = value

props:
  node:
  nodeVar:
  nodeVarPath:
  userAppState:
  sui:

data:
  url:
  initial:
    url:
    linq:
  nodeVarData:
  nodeVarLinqedData:
  error:

mounted: | #js
  function() {
    this.$root.e.on("app.node.changed", this.init.bind(this));
    this.$root.e.on("app.node.changed", this.onAppNodeChanged.bind(this));
    this.$root.e.on("app.state.changed", this.onAppStateChanged.bind(this));
    this.refresh();
  }

methods:
  init: | #js
    function() {
      this.initial = Objects.clone(this.nodeVar);
      this.nodeContext = this.$root.getNodeContext(this, this.sui?.page.selected?.name);
    }
  evalExpItem: | #js
    function(url, dataItem, options) {
      try {
        this.error = null;
        const func = this.$root.toContextFunc(this, dataItem, { args: [], code: `return ${url};` }, { async: false });
        const value = func();
        return value;
      }
      catch (ex) {
        if (options?.ignore?.errors) return null;
        this.error = ex.message;
      }
    }
  onInput: | #js
    function(value) {
      this.initial.url = value;
      this.$root.do("edit.node.var", { node: this.node, varName: this.nodeVar.name, key: "url", value });
    }
  onAppNodeChanged: | #js
    function(node) {
      if (node.id != this.node.id) return;
      this.refresh();
    }
  onAppStateChanged: | #js
    function(vars) {
      const var1 = vars.find(v => (this.nodeVarPath == v.varPath.join(".")));
      if (!var1) return;
      this.refresh();
    }
  setLinq: | #js
    function(linq) {
      if (Objects.areEqual(linq, this.initial.linq)) return;
      this.initial.linq = Objects.clone(linq);
      this.$root.do("edit.node.var", { node: this.node, varName: this.nodeVar.name, key: "linq", value: linq });
    }
  onSaveUrl: | #js
    function() {
      this.$root.do("edit.node.var", { node: this.node, varName: this.nodeVar.name, key: "url", value: this.url });
    }
  refresh: | #js
    function(nodeVar) {
      if (!nodeVar) nodeVar = this.nodeVar;
      this.initial.linq = Objects.clone(nodeVar.linq);
      this.initial.url = this.url = this.nodeVar?.url;
      this.nodeVarData = Objects.getProperty(this.userAppState, this.nodeVarPath);
    }

watch:
  nodeVar:
    immediate: true
    handler: | #js
      function(nodeVar) {
        this.init();
        this.refresh(nodeVar);
      }
