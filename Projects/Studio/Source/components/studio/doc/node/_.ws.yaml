dom:
  studio.doc.node.anim:
    :node: node
    :item-index: itemIndex
    :items-count: itemsCount
    :sui: sui
    studio.doc.node.vars:
      :node: node
      :node-var-path: nodeVarPath
      @update: onNodeVarValueUpdate
    transition:
      name: slide
      component:
        v-if: node
        :key: node.id
        ref: comp1
        :is: nodeCompName
        :node: node
        :user-app: userApp
        :user-app-state: userAppState
        :sui: sui
        :data-item: dataItem
        :content-node: contentNode
        :class: nodeCssClass
        :style: nodeStyle
        :data-sui-page: nodePageName
        :data-node-id: node.id
        v-bind: nodeVarData
        template:
          v-slot: child-nodes
          ui.dom.layout:
            :layout: node.layout
            :show-example: showLayoutExample
            :show-grid-name: "false"
            :key: key1
            transition.group:
              name: slide
              studio.doc.node:
                v-for: childNode in node.children
                :node: childNode
                :user-app: userApp
                :user-app-state: userAppState
                :sui: sui
                :data-item: dataItem
                :content-node: contentNode
                :key: childNode.id

props:
  node:
  userApp:
  userAppState:
  sui:
  dataItem:
  itemIndex:
  itemsCount:
  contentNode:

data:
  key1: 1
  nodeStyle: null
  nodeCssClass: null
  nodeCompName: null
  nodePageName: null
  nodeVarPath: null
  nodeVarData: {}
  showLayoutExample: null

mounted: | #js
  function() {
    this.$root.e.on("app.node.changed", this.onAppNodeChanged.bind(this));
    //this.$watch("sui.node.hovered", this.onSuiNodeChanged.bind(this, "hovered"));
    this.$watch("sui.node.selected", this.onSuiNodeChanged.bind(this, "selected"));
    this.refresh1();
  }

methods:
  onNodeVarValueUpdate: | #js
    function(key, value) {
      if (!value) return;
      this.nodeVarData[key] = value;
    }
  initNodeVars: | #js
    function() {
      const runtimeVue = this.$root.getUserAppRuntimeVue(this);
      if (!runtimeVue) return;
      let comp1 = this.$refs.comp1;
      if (comp1.$options.name == "studio-doc-node-vue-comp") comp1 = comp1.$children[0];
      const vars = this.node.vars;
      if (!vars) return;
      for (const var1 of vars)
      {
        const nodeVar = this.createNodeVar(comp1, var1);
      }
    }
  createNodeVar: | #js
    function(vComp, var1) {
      if (!var1?.type) return;
      const method = this[`createNodeVar.${var1.type}`.replaceAll('.', '_')];
      if (!method) throw `Unknown node var type ${var1.type}`;
      return method(vComp, var1);
    }
  createNodeVar_fetch: | #js
    function(vComp, var1) {
      const $root = this.$root;
      const runtimeVue = $root.getUserAppRuntimeVue(this);
      const pageNode = this.$root.getNodePage(this);
      const sui = this.sui;
      this.bindNodeVarToGlobalAppState(vComp, var1);

      // a fetch var has:
      // - url (computed, can reference other state nodes)
      // - _data (holds the downloaded data)
      // - linq (optional to project the data)
      // - data (the projected downloaded data)
      const url = Vue.computed({
        get: this.$root.toContextFunc(this, { args: ["vue"], code: `try { return ${var1.url}; } catch (ex) {}` }, { async: false })
      });

      const _data = Vue.reactive({ value: null });

      const url_watcher = Vue.watch(url,
        (async function(newUrl) {
          if (!newUrl) return;
          vComp[`${var1.name}Url`] = newUrl;
          _data.value = (await $root.fetchFromUrl(newUrl));
          // #TODO not accurate
          // switch to the page this list is in
          if (pageNode) $root.do("select.page", { pageNode });
        }),
        { immediate: true });

      const _data_watcher = Vue.watch(_data,
        (async function(newData) {
          const linq = (var1.linq || null);
          const datas = runtimeVue.$refs.linqEval1.evaluateOps(null, newData.value, linq);
          const data = datas.last();
          vComp[var1.name] = data;
        })
      );

      const nodeVar = { url, _data };
      
      return nodeVar;
    }
  createNodeVar_field: | #js
    function(vComp, var1) {
      const $root = this.$root;
      const runtimeVue = $root.getUserAppRuntimeVue(this);
      // a field node var has:
      // - value (taken from data-item[field])
      const field_watcher = Vue.watch(
        () => this.dataItem?.[var1.exp],
        (function(newValue) {
          vComp[var1.name] = newValue;
        }),
        { immediate: true });

      return { field_watcher };
    }
  createNodeVar_exp: | #js
    function(vComp, var1) {
      const $root = this.$root;
      const runtimeVue = $root.getUserAppRuntimeVue(this);
      this.bindNodeVarToGlobalAppState(vComp, var1);
      // an exp node var has:
      // - value (evaluated)
      const exp = Vue.computed({
        get: this.$root.toContextFunc(this, { args: ["vue"], code: `try { return ${var1.exp}; } catch (ex) {}` }, { async: false })
      });

      const exp_watcher = Vue.watch(exp,
        (function(newValue) {
          vComp[var1.name] = newValue;
        }),
        { immediate: true });

      return { exp };
    }
  createNodeVar_node_prop: | #js
    function(vComp, var1) {
      const $root = this.$root;
      const runtimeVue = $root.getUserAppRuntimeVue(this);
      this.bindNodeVarToGlobalAppState(vComp, var1);
      // a node prop node var is used to connect to custom vue components
      // it cannot be configued by the user like a [fetch] or [field] var
      // it is used to pass data from the node to the vue component and vice versa
      // example: [selected], [hovered]

      // may be initialized from the node
      vComp[var1.name] = var1.value;

      return { value: var1.value };
    }
  createNodeVar_value: | #js
    function(vComp, var1) {
      const $root = this.$root;
      const runtimeVue = $root.getUserAppRuntimeVue(this);
      this.bindNodeVarToGlobalAppState(vComp, var1);

      // simple value node var
      // for example to set a color or a text
      vComp[var1.name] = var1.value;

      return { value: var1.value };
    }
  bindNodeVarToGlobalAppState: | #js
    function(vComp, var1) {
      // we make sure that changes in the vue component's data property
      // are reflected in the node var app state and vice versa
      const runtimeVue = this.$root.getUserAppRuntimeVue(this);
      if (!runtimeVue) return;
      const varPath = `${this.nodeVarPath}.${var1.name}`;
      // a special case is [v-model] which binds to :value and @input
      if (var1.vModel) {
        vComp.$on("input", (function(newValue) {
          // comp -> global state
          this.$root.studio.user.comp.state.change(this.$root, vComp, var1.name, varPath, newValue);
        }));
        // global state -> comp
        runtimeVue.$watch(varPath, (newValue) => {
          this.node.vue.props[var1.name] = var1.value;
        }, { immediate: true });
      }
      else {
        // comp -> global state
        //if (var1.name == "clickCount") debugger;
        vComp.$watch(var1.name, (newValue) => {
          this.$root.studio.user.comp.state.change(this.$root, vComp, var1.name, varPath, newValue);
        });
        // global state -> comp
        runtimeVue.$watch(varPath, (newValue) => {
          vComp[var1.name] = newValue;
          },
          { immediate: true });
      }
    }
  onAppNodeChanged: | #js
    function(node) {
      if (node?.id != this.node?.id) return;
      this.refresh();
    }
  onSuiNodeChanged: | #js
    function(type, node) {
      this.refresh1();
      if (node?.id != this.node?.id) return;
      if (type == "selected") {
        if (this.dataItem) this.$root.e.emit("data.item.selected", this.dataItem);
      }
    }
  getNodeCompName: | #js
    function(node) {
      if (node.type.startsWith("ui.")) return `studio-doc-node-vue-comp`;
      return `studio-doc-node-${node.type.kebabize()}`;
    }
  getNodeStyle: | #js
    function(node) {
      if (!node) return;
      const s = {};
      const userApp = this.$root.getUserApp?.(this);
      const bgColor = this.toStyleColor(userApp, node.design?.bg.color);
      s['background'] = this.toBackground(node.design?.bg);
      // set text color to contrast the background
      if (bgColor) {
        const textColor = Color.fromHexColor(bgColor).toContrastingTextColor();
        s['color'] = textColor.asHexColor();
        if (textColor.brightness > 0.5) {
          s['text-shadow'] = `-2px 2px 1px black`;
        }
        else {
          s['text-shadow'] = 'none';
        }
      }
      s['width'] = node.layout?.size?.width;
      s['height'] = node.layout?.size?.height;
      s['font-family'] = node.design?.font?.family;
      s['line-height'] = node.design?.line?.height;

      if (this.sui.tool.grid.lines) {
        s['transform'] = `translateZ(${(node.depth * 0.2)}em)`;
      }
      Objects.removeNullValueKeys(s);
      if (!Object.keys(s).length) return null;
      return s;
    }
  getNodeCssClass: | #js
    function(node) {
      const cls = {
        'studio-doc-node': true,
        'hovered-node': this.isHoveredNode,
        'selected-node': this.isSelectedNode,
        'active-node':  this.isActiveNode,
      };
      return cls;
    }
  getShowLayoutExample: | #js
    function(node) {
      if (["list"].includes(node.type)) {
        if (!this.node.children?.length) return true;
      }
      return false;
    }
  toBackground: | #js
    function(bg) {
      const userApp = this.$root.getUserApp?.(this);
      if (!userApp || !bg) return null;
      const color = this.toStyleColor(userApp, bg.color);
      if (!bg.gradient) return color;
      let gradient = (bg.gradient||"");
      const color1 = `${color}`;
      const color2 = `${color}40`;
      gradient = gradient
        .replaceAll("{color1}", color1)
        .replaceAll("{color2}", color2)
      return gradient;
    }
  toStyleColor: | #js
    function(userApp, color) {
      if (!color) return null;
      if (color.palette?.index != null) return userApp.global.design.palette.colors[color.palette.index];
      if (color.value) return color.value;
      return null;
    }
  areNodesRelated: | #js
    function(node1, node2, tryOpposite = true) {
      if (!node1 || !node2) return false;
      if (node1.id == node2.id) return true;
      if (node1.type == "comp.inst") {
        if (node2.type == "comp") {
          if (node1.comp.name == node2.name) return true;
        }
      }
      if (tryOpposite) return this.areNodesRelated(node2, node1, false);
      return false;
    }
  refresh1: | #js
    function() {
      this.nodeCssClass = this.getNodeCssClass(this.node);
    }
  refresh: | #js
    function() {
      this.nodeStyle = this.getNodeStyle(this.node);
      this.key1++;
    }

computed:
  isHoveredNode: | #js
    function() {
      if (!this.node) return false;
      if (this.node?.id == this.sui?.node.hovered?.id) return true;
      return false;
      //return this.areNodesRelated(this.node, this.sui?.node.hovered);
    }
  isSelectedNode: | #js
    function() {
      if (!this.node) return false;
      if (this.node?.id == this.sui?.node.selected?.id) return true;
      return false;
      //return this.areNodesRelated(this.node, this.sui?.node.selected);
    }
  isActiveNode: | #js
    function() {
      if (!this.node) return false;
      if (this.node?.id == this.sui?.node.active?.id) return true;
      return false;
      //return this.areNodesRelated(this.node, this.sui?.node.active);
    }

watch:
  node:
    immediate: true
    handler: | #js
      function(node) {
        this.nodePageName = this.$root.getNodePageName(this.node);
        this.nodeCompName = this.getNodeCompName(this.node);
        this.nodeVarPath = this.$root.getNodeVarPath(node);
        this.nodeStyle = this.getNodeStyle(node);
        this.showLayoutExample = this.getShowLayoutExample(node);
      }
  nodeStyle:
    handler: | #js
      function(nodeStyle) {
      }

style:
  .studio-doc-node:
    transition: all 0.6s, color 0.2s, border 0s
  .node-warning:
    font-size: 120%
    text-align: center
    padding: 1em
    opacity: 0.8
    background: "repeating-linear-gradient(-45deg, #3b3b3b, #3b3b3b 20px, #1f1f1f 20px, #1f1f1f 40px)"
  .hovered-node:
    border: "2px dashed #FFFF0080 !important"
  .selected-node:
    border: "2px dashed #FFFF00 !important"
  .hovered-node, .selected-node:
    box-shadow: "inset -3px 3px 2px black !important"
