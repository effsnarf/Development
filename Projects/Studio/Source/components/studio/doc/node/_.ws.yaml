dom:
  studio.doc.node.anim:
    :node: node
    :item-index: itemIndex
    :items-count: itemsCount
    :sui: sui
    studio.doc.node.vars:
      :style: "{ display: 'none' }"
      :node: node
      :node-var-path: nodeVarPath
      :data-item: dataItem
      @update: onNodeVarValueUpdate
    transition:
      name: slide
      component:
        v-if: node
        :key: node.id
        ref: comp1
        :is: nodeCompName
        :node: node
        :node-var-path: nodeVarPath
        :user-app: userApp
        :user-app-state: userAppState
        :sui: sui
        :data-item: dataItem
        :content-node: contentNode
        :class: nodeCssClass
        :style: nodeStyle
        :data-sui-page: nodePageName
        :data-node-id: node.id
        template:
          v-slot: child-nodes
          ui.dom.layout:
            :layout: node.layout
            :show-example: showLayoutExample
            :show-grid-name: "false"
            :key: key1
            studio.doc.node:
              v-for: childNode in node.children
              :node: childNode
              :user-app: userApp
              :user-app-state: userAppState
              :sui: sui
              :data-item: dataItem
              :content-node: contentNode
              :key: childNode.id

props:
  node:
  userApp:
  userAppState:
  sui:
  dataItem:
  itemIndex:
  itemsCount:
  contentNode:

data:
  key1: 1
  nodeStyle: null
  nodeCssClass: null
  nodeCompName: null
  nodePageName: null
  nodeVarPath: null
  nodeVarData: {}
  showLayoutExample: null

mounted: | #js
  function() {
    this.$root.e.on("app.node.changed", this.onAppNodeChanged.bind(this).throttle(100));
    //this.$watch("sui.node.hovered", this.onSuiNodeChanged.bind(this, "hovered"));
    this.$root.e.on("sui.node.selecteds", this.onSuiNodeSelecteds.bind(this));
    this.refresh1();
  }

methods:
  onNodeVarValueUpdate: | #js
    function(key, value) {
      this.nodeVarData[key] = value;
      const comp1 = this.$refs.comp1;
      if (comp1 && (key in comp1.$data)) comp1.$data[key] = value;
    }
  bindNodeVarToGlobalAppState: | #js
    function(vComp, var1) {
      // we make sure that changes in the vue component's data property
      // are reflected in the node var app state and vice versa
      const runtimeVue = this.$root.getUserAppRuntimeVue(this);
      if (!runtimeVue) return;
      const varPath = `${this.nodeVarPath}.${var1.name}`;
      // a special case is [v-model] which binds to :value and @input
      if (var1.vModel) {
        vComp.$on("input", (function(newValue) {
          // comp -> global state
          this.$root.studio.user.comp.state.change(this.$root, vComp, var1.name, varPath, newValue);
        }));
        // global state -> comp
        runtimeVue.$watch(varPath, (newValue) => {
          this.node.vue.props[var1.name] = var1.value;
        }, { immediate: true });
      }
      else {
        // comp -> global state
        //if (var1.name == "clickCount") debugger;
        vComp.$watch(var1.name, (newValue) => {
          this.$root.studio.user.comp.state.change(this.$root, vComp, var1.name, varPath, newValue);
        });
        // global state -> comp
        runtimeVue.$watch(varPath, (newValue) => {
          vComp[var1.name] = newValue;
          },
          { immediate: true });
      }
    }
  onAppNodeChanged: | #js
    function(node) {
      if (node?.id != this.node?.id) return;
      this.refresh();
    }
  onSuiNodeSelecteds: | #js
    function(selecteds) {
      const node = selecteds.last();
      if (node?.id != this.node?.id) return;
      this.refresh1();
      if (this.dataItem) this.sui.selected.dataItems.push(this.dataItem);
    }
  getNodeCompName: | #js
    function(node) {
      if (node.type.startsWith("ui.")) return `studio-doc-node-vue-comp`;
      return `studio-doc-node-${node.type.kebabize()}`;
    }
  getNodeStyle: | #js
    function(node) {
      if (!node) return;
      const s = {};
      const userApp = this.$root.getUserApp?.(this);
      const bgColor = this.toStyleColor(userApp, node.design?.bg.color);
      s['background'] = this.toBackground(node.design?.bg);
      // set text color to contrast the background
      if (bgColor) {
        const textColor = Color.fromHexColor(bgColor).toContrastingTextColor();
        s['color'] = textColor.asHexColor();
        if (textColor.brightness > 0.5) {
          s['text-shadow'] = `-2px 2px 1px black`;
        }
        else {
          s['text-shadow'] = 'none';
        }
      }
      s['width'] = node.layout?.size?.width;
      s['height'] = node.layout?.size?.height;
      s['font-family'] = node.design?.font?.family;
      s['line-height'] = node.design?.line?.height;

      if (this.sui.tool.grid.lines) {
        s['transform'] = `translateZ(${(node.depth * 0.2)}em)`;
      }
      Objects.removeNullValueKeys(s);
      if (!Object.keys(s).length) return null;
      return s;
    }
  getNodeCssClass: | #js
    function(node) {
      const cls = {
        'studio-doc-node': true,
        'hovered-node': this.isHoveredNode,
        'selected-node': this.isSelectedNode,
        'active-node':  this.isActiveNode,
      };
      return cls;
    }
  getShowLayoutExample: | #js
    function(node) {
      if (["list"].includes(node.type)) {
        if (!this.node.children?.length) return true;
      }
      return false;
    }
  toBackground: | #js
    function(bg) {
      const userApp = this.$root.getUserApp?.(this);
      if (!userApp || !bg) return null;
      const color = this.toStyleColor(userApp, bg.color);
      if (!bg.gradient) return color;
      let gradient = (bg.gradient||"");
      const color1 = `${color}`;
      const color2 = `${color}40`;
      gradient = gradient
        .replaceAll("{color1}", color1)
        .replaceAll("{color2}", color2)
      return gradient;
    }
  toStyleColor: | #js
    function(userApp, color) {
      if (!color) return null;
      if (color.palette?.index != null) return userApp.global.design.palette.colors[color.palette.index];
      if (color.value) return color.value;
      return null;
    }
  areNodesRelated: | #js
    function(node1, node2, tryOpposite = true) {
      if (!node1 || !node2) return false;
      if (node1.id == node2.id) return true;
      if (node1.type == "comp.inst") {
        if (node2.type == "comp") {
          if (node1.comp.name == node2.name) return true;
        }
      }
      if (tryOpposite) return this.areNodesRelated(node2, node1, false);
      return false;
    }
  refresh1: | #js
    function() {
      this.nodeCssClass = this.getNodeCssClass(this.node);
    }
  refresh: | #js
    function() {
      this.nodeStyle = this.getNodeStyle(this.node);
      this.key1++;
    }

computed:
  isHoveredNode: | #js
    function() {
      if (!this.node) return false;
      if (this.node?.id == this.sui?.node.hovered?.id) return true;
      return false;
      //return this.areNodesRelated(this.node, this.sui?.node.hovered);
    }
  isSelectedNode: | #js
    function() {
      if (!this.node) return false;
      if (this.node?.id == this.sui?.node.selected?.id) return true;
      return false;
      //return this.areNodesRelated(this.node, this.sui?.node.selected);
    }
  isActiveNode: | #js
    function() {
      if (!this.node) return false;
      if (this.node?.id == this.sui?.node.active?.id) return true;
      return false;
      //return this.areNodesRelated(this.node, this.sui?.node.active);
    }

watch:
  node:
    immediate: true
    handler: | #js
      function(node) {
        this.nodePageName = this.$root.getNodePageName(this.node);
        this.nodeCompName = this.getNodeCompName(this.node);
        this.nodeVarPath = this.$root.getNodeVarPath(node);
        this.nodeStyle = this.getNodeStyle(node);
        this.showLayoutExample = this.getShowLayoutExample(node);
      }
  nodeStyle:
    handler: | #js
      function(nodeStyle) {
      }

style:
  .studio-doc-node:
    transition: all 0.6s, color 0.2s, border 0s
  .node-warning:
    font-size: 120%
    text-align: center
    padding: 0.5em
    opacity: 0.8
    background: "repeating-linear-gradient(-45deg, #3b3b3b, #3b3b3b 20px, #1f1f1f 20px, #1f1f1f 40px)"
  .node-warning.small:
    padding: 0.2em
  .hovered-node:
    border: "2px dashed #FFFF0080 !important"
  .selected-node:
    border: "2px dashed #FFFF00 !important"
  .hovered-node, .selected-node:
    box-shadow: "inset -3px 3px 2px black !important"
