dom:
  component:
    v-if: node
    ref: comp1
    :is: nodeCompName
    :node: node
    :user-app-state: userAppState
    :sui: sui
    :data-item: dataItem
    :content-node: contentNode
    :class: nodeCssClass
    :style: nodeStyle
    template:
      v-slot: child-nodes
      studio.doc.node:
        v-for: childNode in node.children
        :node: childNode
        :user-app-state: userAppState
        :sui: sui
        :data-item: dataItem
        :content-node: contentNode
        :key: childNode.id

props:
  node:
  userAppState:
  sui:
  dataItem:
  contentNode:

mounted: | #js
  function() {
    this.$root.$on("app.state.changed", this.onAppStateChanged.bind(this));
    this.$watch("sui.node.selected", this.onSelectedNodeChanged.bind(this));
    //this.applyCssClass(this.nodeCssClass);
    //this.applyStyle(this.nodeStyle);
    this.bindNodeVarsToGlobalAppState();
    this.initNodeVars();
  }

methods:
  bindNodeVarsToGlobalAppState: | #js
    function() {
      const runtimeVue = this.$root.getUserAppRuntimeVue(this);
      if (!runtimeVue) return;
      const comp1 = this.$refs.comp1;
      if (!this.nodeVarPath) return;
      const dataKeys = Object.keys(comp1.$data).except("_");
      if (!dataKeys.length) return;
      for (const key of dataKeys) {
        const varPath = `${this.nodeVarPath}.${key}`;
        comp1._studio_watches = (comp1._studio_watches || {});
        if (!comp1._studio_watches[key]) {
          // comp -> global state
          comp1.$watch(key, (newValue) => { this.$root.studio.user.comp.state.change(this.$root, comp1, key, varPath, newValue); });
          // global state -> comp
          runtimeVue.$watch(varPath, (newValue) => { comp1[key] = newValue; }, { immediate: true });
          comp1._studio_watches[key] = true;
        }
      }
    }
  initNodeVars: | #js
    function() {
      const runtimeVue = this.$root.getUserAppRuntimeVue(this);
      if (!runtimeVue) return;
      const comp1 = this.$refs.comp1;
      const vars = this.node.vars;
      if (!vars) return;
      for (const varName in vars)
      {
        const varOptions = vars[varName];
        const nodeVar = this.createNodeVar(comp1, varName, varOptions);
      }
    }
  createNodeVar: | #js
    function(vComp, varName, varOptions) {
      if (!varOptions?.type) return;
      const method = this[`createNodeVar_${varOptions.type}`];
      if (!method) throw `Unknown node var type ${varOptions.type}`;
      return method(vComp, varName, varOptions);
    }
  createNodeVar_fetch: | #js
    function(vComp, varName, varOptions) {
      const $root = this.$root;
      const runtimeVue = $root.getUserAppRuntimeVue(this);
      // a fetch var has:
      // - url (computed, can reference other state nodes)
      // - _data (holds the downloaded data)
      // - linq (optional to project the data)
      // - data (the projected downloaded data)
      const url = Vue.computed({
        get: eval(`(function() {
          return ${varOptions.url};
        })`).bind(this.userAppState)
      });

      const _data = Vue.reactive({ value: null });

      const url_watcher = Vue.watch(url,
        (async function(newUrl) {
          if (!newUrl) return;
          _data.value = (await $root.fetchFromUrl(newUrl));
        }),
        { immediate: true });

      const _data_watcher = Vue.watch(_data,
        (async function(newData) {
          const linq = (varOptions.linq || null);
          const datas = runtimeVue.$refs.linqEval1.evaluateOps(null, newData.value, linq);
          const data = datas.last();
          vComp[varName] = data;
        })
      );

      const nodeVar = { url, _data };
      
      return nodeVar;
    }
  createNodeVar_field: | #js
    function(vComp, varName, varOptions) {
      const $root = this.$root;
      const runtimeVue = $root.getUserAppRuntimeVue(this);
      // a field node var has:
      // - value (taken from data-item[field])
      const field_watcher = Vue.watch(
        () => this.dataItem?.[varOptions.exp],
        (function(newValue) {
          vComp[varName] = newValue;
        }),
        { immediate: true });

      return { field_watcher };
    }
  createNodeVar_exp: | #js
    function(vComp, varName, varOptions) {
      const $root = this.$root;
      const runtimeVue = $root.getUserAppRuntimeVue(this);
      // an exp node var has:
      // - value (evaluated)
      const exp = Vue.computed({
        get: eval(`(function() {
          return ${varOptions.exp};
        })`).bind(this.userAppState)
      });

      const exp_watcher = Vue.watch(exp,
        (function(newValue) {
          vComp[varName] = newValue;
        }),
        { immediate: true });

      return { exp };
    }
  createNodeVar_value: | #js
    function(vComp, varName, varOptions) {
      const $root = this.$root;
      const runtimeVue = $root.getUserAppRuntimeVue(this);
      // a value node var has:
      // - value (taken from value)
      vComp[varName] = varOptions.value;

      return { value: varOptions.value };
    }
  applyCssClass: | #js
    function(cls) {
      // Apply CSS classes to this.$el
      // cls is an object like { cls1: true, cls2: false, ... }
      if (!this.$el?.classList) return;
      Object.keys(cls).forEach(key => {
        if (cls[key]) {
          this.$el.classList.add(key);
        } else {
          this.$el.classList.remove(key);
        }
      });
    }
  applyStyle: | #js
    function(s) {
      // Apply inline styles to this.$el
      // s is an object like { background: 'red', color: 'blue', ... }
      if (!this.$el?.style) return;
      Object.keys(s).forEach(key => {
        this.$el.style[key] = s[key];
      });
    }
  onAppStateChanged: | #js
    function(vars) {
    }
  onSelectedNodeChanged: | #js
    function(node) {
      if (node?.id != this.node?.id) return;
      if (this.dataItem) this.$root.$emit("data.item.selected", this.dataItem);
    }
  getNodeCompName: | #js
    function(node) {
      return `studio-doc-node-${node.type.kebabize()}`;
    }
  getNodeStyle: | #js
    function(node) {
      if (!node) return;
      const s = {};
      s['background'] = `radial-gradient(circle at center, ${node.style?.bg?.color}, #000)`;
      //s['background-color'] = node.style?.bg?.color;
      s['width'] = node.layout?.width;
      s['flex'] = 'none';
      Object.assign(s, this.getFlexStyle(node));
      Objects.removeNullValueKeys(s);
      if (!Object.keys(s).length) return null;
      return s;
    }
  getFlexStyle: | #js
    function(node) {
      if (!node.flex) return {};
      const s = {};
      s.display = "flex";
      s['justify-content'] = (node.flex?.justify?.content || "space-between");
      s['flex-direction'] = this.toFlexDirection(node);
      Objects.removeNullValueKeys(s);
      return s;
    }
  toFlexDirection: | #js
    function(node) {
      switch (node.flex?.dir)
      {
        case "h": return "row";
        case "v": return "column";
      }
      return null;
    }
  areNodesRelated: | #js
    function(node1, node2, tryOpposite = true) {
      if (!node1 || !node2) return false;
      if (node1.id == node2.id) return true;
      if (node1.type == "comp.inst") {
        if (node2.type == "comp") {
          if (node1.comp.name == node2.name) return true;
        }
      }
      if (tryOpposite) return this.areNodesRelated(node2, node1, false);
      return false;
    }

computed:
  nodeVarPath: | #js
    function() {
      return this.$root.getNodeVarPath(this.node);
    }
  nodePageName: | #js
    function() {
      return this.$root.getNodePageName(this);
    }
  nodeCompName: | #js
    function() {
      return this.getNodeCompName(this.node);
    }
  nodeCssClass: | #js
    function() {
      return {
        'hovered-node': this.isHoveredNode,
        'selected-node': this.isSelectedNode,
        'active-node':  this.isActiveNode
      };
    }
  nodeStyle: | #js
    function() {
      return this.getNodeStyle(this.node);
    }
  isHoveredNode: | #js
    function() {
      if (!this.node) return false;
      return this.areNodesRelated(this.node, this.sui?.node.hovered);
    }
  isSelectedNode: | #js
    function() {
      if (!this.node) return false;
      return this.areNodesRelated(this.node, this.sui?.node.selected);
    }
  isActiveNode: | #js
    function() {
      if (!this.node) return false;
      return this.areNodesRelated(this.node, this.sui?.node.active);
    }

watch:
  nodeCssClass:
    handler: | #js
      function(nodeCssClass) {
        //this.applyCssClass(nodeCssClass);
      }
    immediate: true
  nodeStyle:
    handler: | #js
      function(nodeStyle) {
        //this.applyStyle(nodeStyle);
      }
    immediate: true

style:
  .comp-studio-doc-node:
    border: "1px dashed #444"
  .hovered-node:
    border: 2px dashed yellow
  .selected-node:
    border: 4px dashed green
