dom:
  div:

props:
  userApp:

mounted: | #js
  function() {
    const methods = this.$options.methods;
    for (const methodName in methods)
    {
      const method = methods[methodName].bind(this);
      this.$root[methodName] = method;
    }
    this.$root._studio_methods_initialized = true;
  }

methods:
  getNodeIcon: | #js
    function(node, altType) {
      const icons = {
        "user.app": "üíª",
        "page.templates": "üìö",
        "page.template": "üìö",
        pages: "üìú",
        page: "üìú",
        panel: "üóÇÔ∏è",
        list: "üßÆ",
        text: "üÖ∞Ô∏è",
        button: "‚úîÔ∏è",
        comps: "üéÅ",
        comp: "üéÅ",
        "comp.inst": "üì¶",
        image: "üñºÔ∏è",
        "slot.outlet": "üîåüß©",
        "slot.content": "üß©",
        vars: "üìÇüçÉ",
        var: "üßä"
      };
      return ((icons[node?.type] ?? ((!altType) ? "‚ùî" : this.getNodeIcon({ type: altType }))) ?? "‚ùî");
    }
  getNodeText: | #js
    function(node) {
      if (!node) return null;
      let text = (node.slot?.name || node.comp?.name || node.name || node.type);
      if (text != node.type) text = `[${text}]`;
      return text;
    }
  getNodeVarPath: | #js
    function(node) {
      // #TODO might be wrong
      if (!node.name) return null;
      const pageName = this.getNodePageName(node);
      const varPath = [pageName, node.name].map(s => (s||'')).join('.');
      return varPath;
    }
  getNode: | #js
    function(nodeID) {
      if (!nodeID) return null;
      if (nodeID.id) nodeID = nodeID.id;
      if (nodeID.node?.id) nodeID = nodeID.node.id;
      return TreeObject.find(this.userApp, (n) => (n.id == nodeID));
    }
  initNewNode: | #js
    function(userApp, node, options) {
      const addChildren = (!node.children);
      node = Objects.clone(node, { exclude: ["children"] });
      if (addChildren) node.children = [];
      if (!("id" in node)) {
        node.id = this.$root.getNewNodeID(userApp);
      }
      if (options?.childOf) {
        options.childOf.parent.children.insertAt((options.childOf.insertAt ?? 0), node);
      }
      node.animation = {
        anim: null,
        duration: null,
        preview: null
      };
      const layout = {
        type: null,
        grid: null,
        size: {
          width: null,
          height: null
        }
      };
      if (["panel", "list"].includes(node.type)) {
        layout.type = "grid.y";
        layout.direction = null;
        layout.gap = null;
        layout.order = null;
        layout.justify = {
          content: null
        };
        layout.align = {
          items: null,
          content: null
        };
      }

      node.vars = (node.vars || []);

      if (node.type == "text") {
        node.vars.push({
          name: "text",
          type: "value",
          value: null
        });
      }

      if (node.type == "list") {
        node.vars.push({
          name: "items",
          type: "fetch",
          url: null,
          linq: []
        });
        node.vars.push({
          name: "hovered",
          type: "var",
        });
        node.vars.push({
          name: "selected",
          type: "var",
        });
      }

      const namedNodeTypes = ["list"];

      if (namedNodeTypes.includes(node.type)) {
        const nodesOfThisType = TreeObject.filter(userApp, (n) => (n.type == node.type));
        const count = nodesOfThisType.length;
        node.name = `${node.type}${(count)}`;
      }
      
      node.layout = (node.layout ?? {});
      const mergedLayout = Objects.deepMerge(layout, node.layout);
      Object.assign(node.layout, mergedLayout);

      node.design = {
        font: {
          family: null,
          line: {
            height: null
          }
        },
        bg: {
          color: {
            palette: {
              index: null
            },
          },
          gradient: null
        }
      }
      node.flex = (node.flex || {});
      const newFlex = {
        dir: "v",
        justify: {
          items: "center",
          content: "center"
        }
      };
      const mergedFlex = Objects.deepMerge(newFlex, node.flex);
      Object.assign(node.flex, mergedFlex);

      switch (node.type) {
        case "text":
          node.text = (node.text || null);
          node.size = (node.size || null);
          break;
      }

      node.depth = TreeObject.getNodeDepth(userApp, node);
      return node;
    }
  getNewNodeID: | #js
    function(userApp) {
      const maxID = this.getMaxID(userApp);
      const newID = ((maxID || 0) + 1);
      return newID;
    }
  getMaxID: | #js
    function(userApp) {
      userApp = (userApp ?? this.userApp);
      if (!userApp) throw `No user app`;
      let maxID = -1;
      TreeObject.traverse(userApp, (node) => {
        if (node.id > maxID) maxID = node.id;
      });
      if (maxID == -1) return null;
      return maxID;
    }
  findNode: | #js
    function(node, type, compName) {
      for (const childNode of node.children) {
        if (childNode.type != type) continue;
        // found the node by type
        if ((type == "comp") && compName) {
          if (compName != childNode.name) continue;
        }
        return childNode;
      }
    }
  findNodeByPath: | #js
    function(nodePath) {
      if (typeof(nodePath) == 'string') nodePath = nodePath.split('.');
      let node = this.userApp;
      let part;
      while (part = nodePath.shift()) {
        node = this.findNodeByName(node, part);
      }
      return node;
    }
  findNodeByName: | #js
    function(parent, name) {
      return parent.children?.find(c => (name == (c.name || c.type)));
    }
  findDescNodes: | #js
    function(parent, filter) {
      if ((typeof filter) == "string") {
        const type = filter;
        filter = (node) => (node.type == type);
      }
      const nodes = [];
      const search = (node) => {
        if (nodes.map(n => n.id).includes(node.id)) return;
        if (filter(node)) nodes.push(node);
      };
      Objects.traverse(parent, search);
      return nodes;
    }
  getNodes: | #js
    function(parentNode, type) {
      const nodes = [];
      for (const childNode of parentNode.children) {
        if (type == childNode.type) nodes.push(childNode);
      }
      return nodes;
    }
  getCompNode: | #js
    function(compInstNode) {
      return this.getClassNode("comp", compInstNode.comp);
    }
  getNodesByType: | #js
    function(type) {
      const folderNode = this.findNode(this.userApp, type.pluralize());
      const itemNodes = this.getNodes(folderNode, type);
      return itemNodes;
    }
  getRefingNodes: | #js
    function(varPath) {
      const refs = [];
      if (!varPath.includes(".selected")) return [];
      return TreeObject.filter(this.userApp, (n) => (n.data?.source?.path?.join('.').startsWith(varPath)));
    }
  getPageNodes: | #js
    function() {
      return this.getNodesByType("page");
    }
  getPageTemplateNodes: | #js
    function() {
      return this.getNodesByType("page.template");
    }
  getClassNode: | #js
    function(type, inst) {
      const folderNodes = this.getNodesByType(type);
      return folderNodes.find(cls => (cls.name == inst.name));
    }
  getPageName: | #js
    function(vue) {
      while ((vue) && (vue.node?.type != "page")) vue = vue.$parent;
      return vue?.node?.name;
    }
  getPageNames: | #js
    function() {
      const pageNodes = this.getNodesByType("page");
      return pageNodes.map(p => p.name);
    }
  getNodePage: | #js
    function(vue) {
      while ((vue) && (vue.node?.type != "page")) vue = vue.$parent;
      return vue?.node;
    }
  getNodePageName: | #js
    function(node) {
      const ancs = this.getNodeAncestors(node);
      return ancs.find(n => (n.type == "page"))?.name;
    }
  getContainingPageNode: | #js
    function(node) {
      const ancs = this.getNodeAncestors(node);
      return ancs.find(n => (n.type == "page"));
    }
  getNodeNamePath: | #js
    function(node, edge) {
      const ancs = this.getNodeAncestors(node);
      let path = ancs
        .filter(n => n.name)
        .map(n => n.name);
      path.push(node.name);
      if (edge) {
        if ("list" == node.type) path.push("items");
      }
      path = path.filter(p => p);
      return path;
    }
  getNodeAncestors: | #js
    // #TODO Slow
    function(node, ancs = []) {
      while (node = this.getNodeParent(node)) ancs.unshift(node);
      return ancs;
    }
  getNodeParent: | #js
    // #TODO Slow
    function(node) {
      return TreeObject.find(this.userApp, (p => (p.children?.map(c => c.id).includes(node.id))));
    }
  appStateChanged: | #js
    function(vue, icon, method, vars) {
      this.$root.e.emit("app.state.changed", vars);
      this.$root.studio.user.app.log(vue, icon, method, `üßä`, "app.state.changed", vars);
    }
  appNodeChanged: | #js
    function(node) {
      node = this.$root.getNode(node);
      this.$root.e.emit("app.node.changed", node);
    }
  appNodeEdited: | #js
    function(node) {
      node = this.$root.getNode(node);
      this.$root.appNodeChanged(node);
      this.$root.e.emit("app.node.edited", node);
    }
  fetchFromUrl: | #js
    async function(url) {
      const ticker = Ticker.alertify((elapsed) => `<h2>‚è≥ ${elapsed.unitifyTime()}</h2> ${url}`)
      try
      {
        const text = (await (await fetch(`/fetch?url=${url}`)).text());
        // #TODO lame
        try {
          const obj = JSON.parse(text);
          return obj;
        }
        catch { return text; }
      }
      finally
      {
        ticker.stop();
      }
    }
  bindToUserAppState: | #js
    function(vue, nodeVarPath, var1, propName) {
      // local -> userAppState
      Vue.watch(() => vue.$data[propName], (newValue) => {
        const oldValue = this.$root.studio.user.app.state.get(`${nodeVarPath}.${var1.name}.${propName}`);
        if (oldValue == newValue) return;
        this.$root.studio.user.app.state.set(this, `${nodeVarPath}.${var1.name}`, propName, newValue);
        this.$root.studio.user.app.log(this, `üßä`, "$watcher", { dir: "local -> app.state", path: `üßä ${nodeVarPath}.${var1.name}.${propName}`, newValue });
      });
      // userAppState -> local
      this.$root.watchUserAppState(vue, `${nodeVarPath}.${var1.name}`, propName, (newValue) => {
        if (vue.$data[propName] == newValue) return;
        vue.$data[propName] = newValue;
        this.$root.studio.user.app.log(this, `üßä`, "$watcher", { dir: "app.state -> local", path: `üßä ${nodeVarPath}.${var1.name}.${propName}`, newValue });
      });
    }
  watchUserAppState: | #js
    function(vue, nodeVarPath, varName, handler) {
      this.$root.e.on("app.state.changed", (vars) => {
        for (const var1 of vars) {
          if (var1.varPath.join('.') == `${nodeVarPath}.${varName}`) {
            handler(var1.newValue);
          }
        }
      });
    }
  getUserAppRuntimeVue: | #js
    function(vue) {
      while ((vue) && (vue.$options.name != "studio-app-runtime-vue")) vue = vue.$parent;
      return vue;
    }
  getUserAppState: | #js
    function(vue) {
      while (vue && !vue.userAppState) vue = vue.$parent;
      return vue?.userAppState;
    }
  liveNodeVar: | #js
    function(vue, var1, propName, exp, onChange) {
      this.$root.studio.user.app.log(vue, `üßä`, "liveNodeVar.init", { var1, propName, exp });
      const computed = Vue.computed({
        get: this.$root.toContextFunc(vue, { args: ["vue"], code: `try { return ${exp}; } catch (ex) {}` }, { async: false })
      });
      const watcher = Vue.watch(computed, (newValue) => {
        if (!vue.nodeVarPath) return;
        vue.$data[propName] = newValue;
        this.$root.studio.user.app.log(vue, `üßä`, "liveNodeVar.$watcher", { propName, newValue });
        this.$root.studio.user.app.state.set(this, `${vue.nodeVarPath}.${var1.name}`, propName, newValue);
        onChange?.(newValue);
      }, { immediate: true });
      const destroy = () => {
        watcher();
      };
      return { destroy, computed, watcher };
    }
  toContextFunc: | #js
    function(vue, funcDef, options) {
      const isAsync = (options?.async ?? true);
      while (!vue.node) vue = vue.$parent;
      // accepts:
      // { args: ['a', 'b'], code: 'return a + b' }
      // returns a function
      // defaults to async function
      if (!funcDef) return null;
      const argNames = [...(funcDef.args || []), '$app', '$page', '$node'];
      const code = funcDef.code || '';
      const funcStr = `${(isAsync ? "async" : "")} function(${argNames.join(', ')}) { ${code} }`;
      const func = eval(`(${funcStr})`);
      // this.$node.clickCount
      // this.$page.button1, this.$page.boards, etc (data from this page)
      // this.$app.home, this.$app.boards, etc (access other pages)
      const userAppState = this.$root.getUserAppState(vue);
      const pageName = this.$root.getPageName(vue);
      const nodeVarPath = (vue.nodeVarPath ?? this.$root.getNodeVarPath(vue.node));
      const nodeData = (!nodeVarPath) ? null : Objects.getProperty(userAppState, nodeVarPath);
      const $app = userAppState;
      const $page = userAppState[pageName];
      const $node = nodeData;
      const $item = vue.dataItem;
      const context = { $app, $page, $node, $item };
      return function(...args) {
        args.push(...Object.values(context));
        return func.apply(vue, args);
      }
    }
