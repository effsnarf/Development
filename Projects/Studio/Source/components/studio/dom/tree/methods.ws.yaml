dom:
  div:

props:
  userApp:

mounted: | #js
  function() {
    const methods = this.$options.methods;
    for (const methodName in methods)
    {
      const method = methods[methodName].bind(this);
      this.$root[methodName] = method;
    }
    this.$root._studio_methods_initialized = true;
  }

methods:
  getNodeIcon: | #js
    function(node, altType, altIcon) {
      const icons = {
        "user.app": "💻",
        "page.templates": "📚",
        "page.template": "📚",
        pages: "📜",
        page: "📜",
        panel: "📂",
        list: "🧮",
        text: "🅰️",
        textbox: "⌨️",
        button: "✔️",
        comps: "🎁",
        comp: "🎁",
        "comp.inst": "📦",
        image: "🖼️",
        "slot.outlet": "🔌🧩",
        "slot.content": "🧩",
        vars: "📂🍃",
        var: "🧊"
      };
      if (icons[node?.type]) return icons[node?.type];
      if (altType) return this.getNodeIcon({ type: altType }, null, altIcon);
      if (altIcon !== undefined) return altIcon;
      return "❔";
    }
  getNodeText: | #js
    function(node) {
      if (!node) return null;
      let text = (node.slot?.name || node.name || node.comp?.name || node.type);
      if (text != node.type) text = `[${text}]`;
      return text;
    }
  getNodeVarPath: | #js
    function(node, pageName) {
      // #TODO might be wrong
      if (!node.name) return null;
      if (!pageName) pageName = this.getNodePageName(node);
      const varPath = [pageName, node.name].map(s => (s||'')).join('.');
      return varPath;
    }
  getNode: | #js
    function(nodeID) {
      if (!nodeID) return null;
      if (nodeID.id) nodeID = nodeID.id;
      if (nodeID.node?.id) nodeID = nodeID.node.id;
      return TreeObject.find(this.userApp, (n) => (n.id == nodeID));
    }
  # user app state
  getNewUserAppState: | #js
    function(userApp) {
      const pagesNode = TreeObject.getByPath(userApp, ["pages"]);
      return this.getContainerData(pagesNode);
    }
  getContainerData: | #js
    function(container, path = []) {
      const data = {};
      const varsData = this.getNewVarsData(container, path);
      Object.assign(data, varsData);
      const scopeChildren = this.$root.getScopeContainerNodes(container);
      for (const child of scopeChildren) {
        data[child.name] = this.getContainerData(child, [...path, child.name]);
      }
      return data;
    }
  getNewVarsData: | #js
    function(container, path = []) {
      const data = {};
      for (const var1 of (container.vars??[])) {
        data[var1.name] = this.getNewVarData(var1);
        var1.path = [...path, var1.name];
      }
      return data;
    }
  getNewVarData: | #js
    function(var1) {
      const d = {};
      return d;
    }
  # ################
  initNewNode: | #js
    function(userApp, node, options) {
      if (options?.includeChildren) {
        node = Objects.clone(node);
      }
      else {
        const addChildren = (!node.children);
        node = Objects.clone(node, { exclude: ["children"] });
        if (addChildren) node.children = [];
      }

      options = (options ?? {});

      if (node.type == "page") {
        if (options.insert?.page) {
          const pagesNode = userApp.children.find(n => (n.type == "pages"));
          if (!pagesNode) throw `No pages node`;
          options.childOf = {
            parent: pagesNode,
            insertAt: (pagesNode.children.length)
          }
        }
      }

      if (options.childOf) {
        options.childOf.parent.children.insertAt((options.childOf.insertAt ?? 0), node);
      }

      if ((node.type == "page") && (options.insert?.page)) {
        const slotOutlets = this.getSlotOutlets(userApp, node);
        node.children = (node.children ?? []);
        node.children.push(...slotOutlets.map(s => this.getNewSlotContent(userApp, s)));
      }

      if (!(options && (options.new?.id == false))) this.ensureNodeIDs(userApp, node);

      node.animation = {
        anim: null,
        duration: null,
        preview: null
      };

      const layout = {
        type: "grid.y",
        grid: null,
        direction: null,
        gap: null,
        order: null,
        justify: {
          content: null
        },
        align: {
          items: null,
          content: null
        },
        size: {
          width: null,
          height: null
        }
      };
      node.layout = (node.layout ?? {});
      const mergedLayout = Objects.deepMerge(layout, node.layout);
      Object.assign(node.layout, mergedLayout);

      node.vars = (node.vars || []);

      if (node.type == "text") {
        if (!node.vars.find(v => (v.name == "text"))) {
          const textVar = {
            name: "text",
            type: "value",
            value: `Text ${node.id}`,
            exp: null
          };
          if (options.childOf.parent.type == "list") {
            textVar.type = "field";
          }
          node.vars.push(textVar);
        }
      }

      if (node.type == "textbox") {
        if (!node.vars.find(v => (v.name == "text"))) {
          node.vars.push({
            name: "text",
            type: "var",
          });
        }
      }

      if (node.type == "image") {
        if (!node.vars.find(v => (v.name == "url"))) {
          node.vars.push({
            name: "imageUrl",
            type: "exp",
            value: null,
            exp: null
          });
        }
      }

      if (node.type == "list") {
        node.vars.push({
          name: "items",
          type: "fetch",
          url: null,
          linq: []
        });
        node.vars.push({
          name: "hovered",
          type: "var",
        });
        node.vars.push({
          name: "selected",
          type: "var",
        });
      }

      const namedNodeTypes = ["list", "textbox"];

      if (namedNodeTypes.includes(node.type)) {
        node.name = this.getNewNodeName(userApp, node.type);
      }
      
      node.design = {
        font: {
          family: null,
          line: {
            height: null
          }
        },
        bg: {
          color: {
            palette: {
              index: null
            },
          },
          gradient: null
        }
      }

      switch (node.type) {
        case "text":
          node.size = (node.size || 2);
          break;
      }

      // #TODO Slow
      // if we just added this node to the user app
      // we need to set its node var paths
      // which is done when we build a new user app state tree
      if (options.childOf) {
        this.getNewUserAppState(userApp);
      }

      node.depth = TreeObject.getNodeDepth(userApp, node);

      return node;
    }
  createNewPageNode: | #js
    function(userApp, pageName, pageTemplateName) {
      const pagesNode = this.userApp.children.find(n => (n.type == "pages"));
      let page = {
        id: this.$root.getNewNodeID(userApp),
        type: "page",
        name: pageName,
        page: {
          template: {
            name: pageTemplateName,
          }
        },
        children: []
      };
      page = this.$root.initNewNode(userApp, page, { insert: { page: true } });
      return page;
    }
  getSlotOutlets: | #js
    function(userApp, templateNode) {
      if (templateNode.type == "page") templateNode = this.getPageTemplateNode(userApp, templateNode);
      const slotOutlets = [];
      TreeObject.traverse(templateNode, (node) => {
        if (node.type == "slot.outlet") slotOutlets.push(node);
      });
      return slotOutlets;
    }
  getPageTemplateNode: | #js
    function(userApp, pageNode) {
      return TreeObject.find(userApp, (n) => (n.type == "page.template") && (n.name == pageNode.page.template.name));
    }
  getNewSlotContent: | #js
    function(userApp, slotOutlet) {
      let node = {
        type: "slot.content",
        slot: {
          name: slotOutlet.name
        },
        children: []
      };
      node = this.$root.initNewNode(userApp, node, { new: { id: false }, includeChildren: true });
      return node;
    }
  ensureNodeIDs: | #js
    function(userApp, node) {
      if (!("id" in node)) {
        node.id = this.$root.getNewNodeID(userApp);
      }
      for (const childNode of (node.children??[])) {
        this.ensureNodeIDs(userApp, childNode);
      }
    }
  getNewNodeID: | #js
    function(userApp) {
      const maxID = this.getMaxID(userApp);
      const newID = ((maxID || 0) + 1);
      return newID;
    }
  getMaxID: | #js
    function(userApp) {
      userApp = (userApp ?? this.userApp);
      if (!userApp) throw `No user app`;
      let maxID = -1;
      TreeObject.traverse(userApp, (node) => {
        if (node.id > maxID) maxID = node.id;
      });
      if (maxID == -1) return null;
      return maxID;
    }
  findNode: | #js
    function(node, type, compName) {
      for (const childNode of node.children) {
        if (childNode.type != type) continue;
        // found the node by type
        if ((type == "comp") && compName) {
          if (compName != childNode.name) continue;
        }
        return childNode;
      }
    }
  findNodeByID: | #js
    function(node, id) {
      if (!id) return null;
      if (id.id) id = id.id;
      return TreeObject.find(node, (n) => (n.id == id));
    }
  findNodeByPath: | #js
    function(nodePath) {
      if (typeof(nodePath) == 'string') nodePath = nodePath.split('.');
      let node = this.userApp;
      let part;
      while (part = nodePath.shift()) {
        node = this.findNodeByName(node, part);
      }
      return node;
    }
  findNodeByName: | #js
    function(parent, name) {
      return parent.children?.find(c => (name == (c.name || c.type)));
    }
  findNodeByName2: | #js
    function(parent, name) {
      return TreeObject.find(parent, (n) => (name == n.name));
    }
  findDescNodes: | #js
    function(parent, filter) {
      if ((typeof filter) == "string") {
        const type = filter;
        filter = (node) => (node.type == type);
      }
      return TreeObject.filter(parent, filter);
    }
  getContainerNodeByPath: | #js
    function(path) {
      if (typeof(path) == 'string') path = path.split('.');
      console.log(path.join('.'));
      if (!path.length) return null;
      let node = this.userApp;
      let part;
      while (part = path.shift()) {
        const scopeNodes = this.getScopeContainerNodes(node);
        node = scopeNodes.find(n => (n.id == part) || (n.name == part));
      }
      console.log(node);
      return node;
    }
  getScopeContainerNodes: | #js
    function(parent) {
      if (!parent) return [];
      if (parent.type == "comp.inst") {
        const compNode = this.getCompNode(parent);
        parent = compNode;
      }
      // get all descendant data container nodes not their children
      return TreeObject.filter(parent, (n => this.isContainerNode(parent, n)), (n => (this.isContainerNode(parent, n) ? [] : n.children)));
    }
  isContainerNode: | #js
    function(parent, node) {
      if (node == parent) return false;
      if (["page.template", "slot.content", "slot.outlet"].includes(node.type)) return false;
      if (node.name) return true;
      return false;
    }
  getNodes: | #js
    function(parentNode, type) {
      const nodes = [];
      for (const childNode of parentNode.children) {
        if (type == childNode.type) nodes.push(childNode);
      }
      return nodes;
    }
  getCompNode: | #js
    function(compInstNode) {
      return this.getClassNode("comp", compInstNode.comp);
    }
  getNodesByType: | #js
    function(type) {
      const folderNode = this.findNode(this.userApp, type.pluralize());
      const itemNodes = this.getNodes(folderNode, type);
      return itemNodes;
    }
  getRefingNodes: | #js
    function(varPath) {
      const refs = [];
      if (!varPath.includes(".selected")) return [];
      return TreeObject.filter(this.userApp, (n) => (n.data?.source?.path?.join('.').startsWith(varPath)));
    }
  getPageNodes: | #js
    function() {
      return this.getNodesByType("page");
    }
  getPageTemplateNodes: | #js
    function() {
      return this.getNodesByType("page.template");
    }
  getClassNode: | #js
    function(type, inst) {
      const folderNodes = this.getNodesByType(type);
      return folderNodes.find(cls => (cls.name == inst.name));
    }
  getPageName: | #js
    function(vue) {
      while ((vue) && (vue.node?.type != "page")) vue = vue.$parent;
      return vue?.node?.name;
    }
  getPageNames: | #js
    function() {
      const pageNodes = this.getNodesByType("page");
      return pageNodes.map(p => p.name);
    }
  getNodePage: | #js
    function(vue) {
      while ((vue) && (vue.node?.type != "page")) vue = vue.$parent;
      return vue?.node;
    }
  getNodePageName: | #js
    function(node) {
      const ancs = this.getNodeAncestors(node);
      return ancs.find(n => (n.type == "page"))?.name;
    }
  getContainingPageNode: | #js
    function(node) {
      const ancs = this.getNodeAncestors(node);
      return ancs.find(n => (n.type == "page"));
    }
  getNodeNamePath: | #js
    function(node, edge) {
      const ancs = this.getNodeAncestors(node);
      let path = ancs
        .filter(n => n.name)
        .map(n => n.name);
      path.push(node.name);
      if (edge) {
        if ("list" == node.type) path.push("items");
      }
      path = path.filter(p => p);
      return path;
    }
  getNodeAncestors: | #js
    // #TODO Slow
    function(node, ancs = []) {
      while (node = this.getNodeParent(node)) ancs.unshift(node);
      return ancs;
    }
  getNodeParent: | #js
    // #TODO Slow
    function(node) {
      return TreeObject.find(this.userApp, (p => (p.children?.map(c => c.id).includes(node.id))));
    }
  appStateChanged: | #js
    function(vue, icon, method, vars) {
      this.$root.e.emit("app.state.changed", vars);
      this.$root.studio.user.app.log(vue, icon, method, `🧊`, "app.state.changed", vars);
    }
  appNodeChanged: | #js
    function(node) {
      node = this.$root.getNode(node);
      this.$root.e.emit("app.node.changed", node);
    }
  appNodeEdited: | #js
    function(node) {
      node = this.$root.getNode(node);
      this.$root.appNodeChanged(node);
      this.$root.e.emit("app.node.edited", node);
    }
  fetchFromUrl: | #js
    async function(url) {
      if (!url) return null;
      console.log(`🌐 ${url}`);
      const ticker = Ticker.alertify((elapsed) => `<h2>⏳ ${elapsed.unitifyTime()}</h2> ${url}`)
      try
      {
        const text = (await (await fetch(`/fetch?url=${url}`)).text());
        // #TODO lame
        try {
          const obj = JSON.parse(text);
          return obj;
        }
        catch { return text; }
      }
      finally
      {
        ticker.stop();
      }
    }
  bindToUserAppState: | #js
    function(vue, vueDataKey, nodeVarPath, onVarValueChanged) {
      // local -> userAppState
      Vue.watch(() => vue.$data[vueDataKey], (newValue) => {
        const oldValue = this.$root.studio.user.app.state.get(nodeVarPath);
        if (oldValue == newValue) return;
        this.$root.studio.user.app.state.set(nodeVarPath, newValue);
        //this.$root.studio.user.app.log(this, `🧊`, "$watcher", { dir: "local -> app.state", path: `🧊 ${nodeVarPath}.${var1.name}.${propName}`, newValue });
      });
      // userAppState -> local
      this.$root.watchUserAppState(vue, nodeVarPath, (newValue) => {
        if (vue.$data[vueDataKey] == newValue) return;
        vue.$data[vueDataKey] = newValue;
        onVarValueChanged?.();
        //this.$root.studio.user.app.log(this, `🧊`, "$watcher", { dir: "app.state -> local", path: `🧊 ${nodeVarPath}.${var1.name}.${propName}`, newValue });
      });
    }
  watchUserAppState: | #js
    function(vue, nodeVarPath, handler) {
      this.$root.e.on("app.state.changed", (vars) => {
        for (const var1 of vars) {
          if (var1.varPath.join('.') == nodeVarPath) {
            handler(var1.newValue);
          }
        }
      });
    }
  getUserAppRuntimeVue: | #js
    function(vue) {
      while ((vue) && (vue.$options.name != "studio-app-runtime-vue")) vue = vue.$parent;
      return vue;
    }
  getUserAppState: | #js
    function(vue) {
      while (vue && !vue.userAppState) vue = vue.$parent;
      return vue?.userAppState;
    }
  getNewNodeName: | #js
    function(userApp, name) {
      let index = 1;
      while (this.findNodeByName2(userApp, `${name}${index}`)) index++;
      return `${name}${index}`;
    }
  liveNodeVar: | #js
    function(vue, var1, propName, exp, onChange) {
      this.$root.studio.user.app.log(vue, `🧊`, "liveNodeVar.init", { var1, propName, exp });
      const computed = Vue.computed({
        get: this.$root.toContextFunc(vue, null, { args: ["vue"], code: `try { return ${exp}; } catch (ex) {}` }, { async: false })
      });
      const watcher = Vue.watch(computed, (newValue) => {
        const oldValue = this.$root.studio.user.app.state.get(`${vue.nodeVarPath}.${var1.name}.${propName}`);
        if (oldValue == newValue) return;
        vue.$data[propName] = newValue;
        //this.$root.studio.user.app.log(vue, `🧊`, "liveNodeVar.$watcher", { propName, newValue });
        this.$root.studio.user.app.state.set(`${vue.nodeVarPath}.${var1.name}`, propName, newValue);
        onChange?.(newValue);
      }, { immediate: true });
      const destroy = () => {
        watcher();
      };
      return { destroy, computed, watcher };
    }
  getNodeContext: | #js
    function(vue, pageName, dataItem) {
      // this.$node.clickCount
      // this.$page.button1, this.$page.boards, etc (data from this page)
      // this.$app.home, this.$app.boards, etc (access other pages)
      const userAppState = this.$root.getUserAppState(vue);
      if (!pageName) pageName = this.$root.getPageName(vue);
      const nodeVarPath = (vue.nodeVarPath ?? this.$root.getNodeVarPath(vue.node, pageName));
      const nodeData = (!nodeVarPath) ? null : Objects.getProperty(userAppState, nodeVarPath);
      const $app = userAppState;
      const $page = userAppState[pageName];
      const $node = nodeData;
      const $item = (dataItem ?? vue.dataItem);
      const context = { $item, $node, $page, $app };
      if ($item) for (const key in $item) context[key] = $item[key];
      return context;
    }
  toContextFunc: | #js
    function(vue, dataItem, funcDef, options) {
      const isAsync = (options?.async ?? true);
      while (!vue.node) vue = vue.$parent;
      // accepts:
      // { args: ['a', 'b'], code: 'return a + b' }
      // returns a function
      // defaults to async function
      if (!funcDef) return null;
      const context = this.$root.getNodeContext(vue, null, dataItem);
      const argNames = [...(funcDef.args || []), ...Object.keys(context)];
      const code = funcDef.code || '';
      const funcStr = `${(isAsync ? "async" : "")} function(${argNames.join(', ')}) { ${code} }`;
      const func = eval(`(${funcStr})`);
      return function(...args) {
        args.push(...Object.values(context));
        return func.apply(vue, args);
      }
    }
  confirm: | #js
    function(message) {
      return new Promise((resolve) => {
          const confirmed = window.confirm(message);
          resolve(confirmed);
        });
      }
