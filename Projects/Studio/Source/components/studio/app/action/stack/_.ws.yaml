dom:
  div:
    .flex.justify-between.items-center:
      h3:
        .flex.gap-05:
          div:
            v-text: "'üñ±Ô∏èüëÜ actions'"
          .dimmed:
            v-text: "'(' + actions.totalCount + ')'"
          div:
            v-text: pointer
      .flex.justify-center:
        button:
          title: "undo (ctrl + z)"
          v-text: "'‚§∫'"
          @click: undo
        button:
          title: "redo (ctrl + y)"
          v-text: "'‚§ª'"
          @click: redo
      div:
        button:
          title: "clear all"
          v-text: "'‚ùå'"
          @click: clearAll
    pre:
      v-text: userApp.ui.selected.nodes
    studio.app.action.stack.list:
      :actions: actions
      :pointer: pointer

props:
  userApp:
  sui:

data:
  actions: []
  pointer: -1
  remote:
    actions:
    pointer:
  key1: 1

mounted: | #js
  async function() {
    this.$root.do = this._do.bind(this);
    // ctrl + z, ctrl + y
    window.addEventListener("keydown", (e) => {
      // ignore events from [input] and [textarea]
      if ([ "input", "textarea" ].includes(e.target.tagName.toLowerCase())) return;
      if (e.ctrlKey && e.key == "z") this.undo();
      if (e.ctrlKey && e.key == "y") this.redo();
    });

    this.remote.actions = await this.$root.data.array("Actions", this.actions);
    this.remote.pointer = await this.$root.data.vue.reactive("Pointers", this, "pointer", -1);
    //this.remote.actions.events.on("after.array.op", this.refresh.bind(this));
    this.updateSuiFromUserApp();
  }

methods:
  clearAll: | #js
    function() {
      let vue = this;
      while (!vue.$data.userApp) vue = vue.$parent;
      this.sui.page.selected = null;
      this.sui.node.selecteds.splice(0);
      this.actions.splice(0);
      this.pointer = -1;
      vue.userApp = (vue.getMockupUserApp());
    }
  updateSuiFromUserApp: | #js
    function() {
      // page
      this.sui.page.selected = this.$root.findNodeByID(this.userApp, this.userApp.ui.selected.page);
      // nodes
      this.sui.node.selecteds = this.userApp.ui.selected.nodes.map(n => this.$root.findNodeByID(this.userApp, n));
      // tool category
      this.sui.tool.category.index = this.userApp.ui.selected.tool.category.index;
      this.sui.tool.category.name = this.sui.tool.category.options[this.sui.tool.category.index]?.split(' ').last();
    }
  do_select_page: | #js
    function(_do, pageNode) {
      let oldPageNode = this.sui.page.selected;
      if ((!oldPageNode && !pageNode) || (oldPageNode?.id == pageNode?.id)) {
        this.userApp.ui.selected.page = null;
        return;
      }
      pageNode = this.$root.getNode(pageNode);
      this.userApp.ui.selected.page = (!pageNode ? null : { id: pageNode.id });
      this.sui.page.selected = pageNode;
      this.setIconText(_do, pageNode);
      const node = this.sui.node;
      node.hovered = node.selected = node.active = node.context = null;
      oldPageNode = this.onlyNodeID(oldPageNode);
      const undo = { type: "select.page", args: { pageNode: oldPageNode } };
      return { _do, undo };
    }
  do_select_tool_category: | #js
    function(_do, index) {
      const oldIndex = this.sui.tool.category.index;
      if (((!oldIndex) && (!index)) || (oldIndex == index)) return;
      const oldIcon = this.sui.tool.category.icons[oldIndex];
      const newIcon = this.sui.tool.category.icons[index];
      const name = this.sui.tool.category.options[index]?.split(' ').last();
      this.sui.tool.category.index = index;
      this.sui.tool.category.name = name;
      this.userApp.ui.selected.tool.category.index = index;
      _do.icon = newIcon;
      _do.text = name;
      const undo = { type: "select.tool.category", args: { index: oldIndex } };
      return { _do, undo };
    }
  do_select_node: | #js
    function(_do, selectIndex, node) {
      if (!node) return;
      const selecteds = this.sui.node.selecteds;
      const oldSelectedNodes = selecteds.map(n => ({ id: n.id }));
      const oldSelectedPage = this.onlyNodeID(this.sui.page.selected);
      // clear anything above selectIndex
      selecteds.splice(selectIndex);
      node = this.$root.getNode(node);
      selecteds.push(node);
      this.userApp.ui.selected.nodes = selecteds.map(n => ({ id: n.id }));
      // if this is a page node, set sui.page.selected
      if (node?.type == "page") this.do_select_page(_do, node);
      this.setIconText(_do, node);
      const undo = { type: "select.nodes", args: { nodes: oldSelectedNodes } };
      this.$root.e.emit("sui.node.selecteds", selecteds);
      return { _do, undo };
    }
  do_select_nodes: | #js
    function(_do, nodes) {
      const selecteds = this.sui.node.selecteds;
      const oldSelectedNodes = selecteds.map(n => ({ id: n.id }));
      selecteds.splice(0);
      for (let i = 0; i < nodes.length; i++) {
        this.do_select_node(_do, i, nodes[i]);
      }
      this.userApp.ui.selected.nodes = selecteds.map(n => ({ id: n.id }));
      this.setIconText(_do, selecteds.last());
      const undo = { type: "select.nodes", args: { nodes: oldSelectedNodes } };
      return { _do, undo };
    }
  do_create_comp: | #js
    function(_do, contentNode, compName) {
      _do.args.contentNode = Objects.clone(contentNode);
      const parent = this.$root.getNodeParent(contentNode);
      const contentNodeIndex = parent.children.findIndex(n => (n.id == contentNode.id));
      const compsNode = this.userApp.children.find(n => (n.type == "comps"));
      let newCompNode = {
        type: "comp",
        name: compName,
      };
      newCompNode = this.$root.initNewNode(this.userApp, newCompNode);
      compsNode.children.push(newCompNode);
      TreeObject.moveNode(this.userApp, contentNode, newCompNode, { newTree: false });
      // insert a comp inst node instead of the content node
      const compInstName = this.$root.getNewNodeName(newCompNode.name);
      const compInstNode = {
        id: this.$root.getNewNodeID(this.userApp),
        type: "comp.inst",
        comp: { id: newCompNode.id, name: newCompNode.name },
        name: compInstName,
      };
      TreeObject.addNode(parent, compInstNode, contentNodeIndex);
      this.setIconText(_do, newCompNode, false, `üì¶ ${compInstName}`);
      const undo = { type: "uncreate.comp", args: { parent: { node: { id: parent.id } }, comp: { node: { id: newCompNode.id } }, index: contentNodeIndex } };
      this.$root.e.emit("app.node.changed", parent);
      this.$root.e.emit("new.comp.created", newCompNode);
      return { _do, undo };
    }
  do_uncreate_comp: | #js
    function(_do, parent, comp, index) {
      parent = this.$root.getNode(parent);
      comp = this.$root.getNode(comp);
      const compInst = parent.children[index];
      // delete the component instance node
      TreeObject.deleteNode(parent, compInst, { newTree: false });
      // remove the comp node from comps
      TreeObject.deleteNode(this.userApp, comp, { newTree: false });
      // unpack the comp back to [parent]
      const contentNode = Objects.clone(comp.children[0]);
      TreeObject.addNode(parent, contentNode, index);
      this.$root.e.emit("app.node.changed", parent);
    }
  do_create_node: | #js
    function(_do, parent, newNode) {
      newNode = Objects.clone(newNode);
      delete newNode._;
      parent = this.$root.getNode(parent);
      newNode = this.$root.initNewNode(this.userApp, newNode, { childOf: { parent, insertAt: 0 } });
      this.sui.node.selected = newNode;
      this.setIconText(_do, newNode);
      const undo = { type: "delete.node", args: { node: { id: newNode.id } } };
      this.$root.e.emit("app.node.changed", parent);
      return { _do, undo };
    }
  do_delete_node: | #js
    function(_do, node) {
      node = this.$root.getNode(node);
      let parent = this.$root.getNodeParent(node);
      const index = parent.children.findIndex(n => (n.id == node.id));
      parent = { node: { id: parent.id } };
      TreeObject.deleteNode(this.userApp, node, { newTree: false });
      this.setIconText(_do, parent);
      const undo = { type: "undelete.node", args: { parent, node, index } };
      this.$root.e.emit("app.node.changed", parent.node);
      return { _do, undo };
    }
  do_edit_node: | #js
    function(_do, oldNode, newNode, changes, isFirstTime) {
      let undoChanges = [];
      if (oldNode && newNode) {
        delete oldNode.children;
        delete newNode.children;
        changes = DeepDiff.diff(oldNode, newNode);
        undoChanges = DeepDiff.diff(newNode, oldNode);
        if (!changes) return alertify.error("No changes detected");
      }

      if (isFirstTime) {
        // group with previous edit, if any
        const prevAction = this.actions.last();
        if (prevAction?.do.type == "edit.node") {
          if (prevAction.do.args.node.id == oldNode.id) {
            undoChanges = prevAction.undo.args.changes;
            this.actions.pop();
          }
        }
      }

      let node = this.$root.getNode(oldNode);

      // if comp name changed, update comp inst names
      if ((node.type == "comp") && (changes.length == 1) && (Objects.areEqual(changes[0].path, ["name"]))) {
        const compInsts = TreeObject.filter(this.userApp, (n) => (n.type == "comp.inst" && n.comp.id == oldNode.id));
        const newName = changes[0].rhs;
        for (const compInst of compInsts) {
          compInst.comp.name = newName;
          this.$root.appNodeChanged(compInst);
        }
      }

      const prevNode = Objects.clone(node, { exclude: ["children"] });
      for (const change of changes) DeepDiff.applyChange(node, change);
      if (!undoChanges.length) {
        const node2 = Objects.clone(node, { exclude: ["children"] });
        undoChanges = DeepDiff.diff(node2, prevNode);
      }
      _do = { type: "edit.node", args: { node, newNode: null, changes } };
      this.setIconText(_do, node, true, this.getActionInfo(changes));
      const undo = { type: "edit.node", args: { node: { id: node.id }, newNode: null, changes: undoChanges } };
      this.$root.appNodeEdited(node);
      return { _do, undo };
    }
  getActionInfo: | #js
    function(changes) {
      let info = (changes[0].item?.rhs?.type ?? changes[0].item?.rhs ?? changes[0].rhs);
      if ((typeof info == "object")) info = null;
      return info;
    }
  do_edit_node_var: | #js
    function(_do, node, varName, key, value) {
      node = this.$root.getNode(node);
      const oldNode = Objects.clone(node, { exclude: ["children"] });
      const nodeVar = node.vars.find(v => (v.name == varName));
      const oldValue = Objects.clone(nodeVar[key]);
      nodeVar[key] = value;
      const newNode = Objects.clone(node);
      const editNodeAction = this.do_edit_node(_do, oldNode, newNode, null);
      if (!editNodeAction._do) return;
      this.setIconText(_do, node, true, editNodeAction._do.info);
      const undo = { type: "edit.node.var", args: { node: { id: node.id }, varName, key, value: oldValue } };
      this.$root.appNodeChanged(node);
      return { _do, undo };
    }
  do_undelete_node: | #js
    function(_do, parent, node, index) {
      parent = this.$root.getNode(parent);
      TreeObject.addNode(parent, node, index);
      const undo = { type: "delete.node", args: { node: { id: node.id } } };
      this.$root.e.emit("app.node.changed", parent);
      return { _do, undo };
    }
  undo: | #js
    function() {
      if (this.pointerToLocalIndex(this.pointer) < 0) return alertify.error("Nothing to undo");
      const action = this.getAction(this.pointer);
      this.do(action.undo, false);
      this.pointer--;
    }
  redo: | #js
    function() {
      if (this.pointer >= this.actions.last()?._i) return alertify.error("Nothing to redo");
      this.pointer++;
      const action = this.getAction(this.pointer);
      this.do(action.do, false);
    }
  do: | #js
    function(_do, addToStack = true) {
      const isFirstTime = (addToStack);
      const doMethod = this[`do_${_do.type.replace(/\./g, "_")}`];
      if (!doMethod) return alertify.error(`Action type not implemented: ${doAction.type}`);
      const action = doMethod(_do, ...Object.values(_do.args), isFirstTime);
      if (!addToStack || !action) return;
      this.addAction(action);
      //this.$root.studio.user.app.log(this, `üñ±Ô∏è`, "do", { action });
    }
  _do: | #js
    function(type, args, addToStack = true) {
      this.do({ type, args }, addToStack);
    }
  addAction: | #js
    function(action) {
      const localPointer = this.pointerToLocalIndex(this.pointer);
      const lastAction = this.actions.last();
      const lastDoneAction = this.actions[this.pointer];
      action._i = (lastDoneAction?._i ?? -1) + 1;
      action.id = (lastAction?.id ?? 0) + 1;
      if (this.pointer < this.actions.last()?._i) {
        this.actions.splice(localPointer + 1);
      }
      if (action._do) {
        action.do = action._do;
        delete action._do;
      }
      this.actions.add(action);
      this.pointer++;
      this.refresh();
    }
  setIconText: | #js
    function(_do, node, shortenNodeRefs = true, info = null) {
      _do.icon = this.$root.getNodeIcon(node);
      _do.text = this.$root.getNodeText(node);
      // find any node props in _do.args (has [id] and [type]) and keep only their { id: [id] }
      if (shortenNodeRefs) {
        for (const key in _do.args) {
          const value = _do.args[key];
          if (value?.id && value?.type) _do.args[key] = { id: value.id };
        }
      }
      if (info) _do.info = info;
    }
  getAction: | #js
    function(index) {
      return this.actions.find(a => (a._i == index));
    }
  pointerToLocalIndex: | #js
    function(pointer) {
      return this.actions.findIndex(a => (a._i == pointer));
    }
  refresh: | #js
    function() {
      this.key1++;
    }
  onlyNodeID: | #js
    function(node) {
      return (!node) ? null : { id: node.id };
    }

watch:
  pointer: | #js
    function(newPointer) {
      this.refresh();
    }

style:
  h3:
    white-space: nowrap
