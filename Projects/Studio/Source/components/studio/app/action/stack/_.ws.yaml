dom:
  div:
    .flex.justify-between.items-center:
      h3:
        .flex.gap-05:
          div:
            v-text: "'🖱️👆 actions'"
          .dimmed:
            v-text: "'(' + actions.totalCount + ')'"
          div:
            v-text: pointer
      .flex.justify-center:
        button:
          title: "undo (ctrl + z)"
          v-text: "'⤺'"
          @click: undo
        button:
          title: "redo (ctrl + y)"
          v-text: "'⤻'"
          @click: redo
      div:
        button:
          title: "clear all"
          v-text: "'❌'"
          @click: clearAll
    studio.app.action.stack.list:
      :actions: actions
      :pointer: pointer

props:
  userApp:
  sui:

data:
  actions: []
  pointer: -1
  remote:
    actions:
    pointer:
  key1: 1

mounted: | #js
  async function() {
    this.$root.do = this._do.bind(this);
    // ctrl + z, ctrl + y
    window.addEventListener("keydown", (e) => {
      // ignore events from [input] and [textarea]
      if ([ "input", "textarea" ].includes(e.target.tagName.toLowerCase())) return;
      if (e.ctrlKey) {
        const op = (e.key == "z") ? "undo" : (e.key == "y") ? "redo" : null;
        if (op) {
          e.preventDefault();
          e.stopPropagation();
          this[op]();
        }
      }
    });

    this.remote.actions = await this.$root.data.array("Actions", this.actions);
    this.remote.pointer = await this.$root.data.vue.reactive("Pointers", this, "pointer", -1);
    //this.remote.actions.events.on("after.array.op", this.refresh.bind(this));
    this.updateSuiFromUserApp();
    this.$root.e.emit("app.loaded");
  }

methods:
  clearAll: | #js
    function() {
      let vue = this;
      while (!vue.$data.userApp) vue = vue.$parent;
      this.sui.page.selected = null;
      this.sui.node.selecteds.splice(0);
      this.actions.splice(0);
      this.pointer = -1;
      vue.userApp = (vue.getMockupUserApp());
      this.$root.e.emit("rebuild.app.state");
    }
  updateSuiFromUserApp: | #js
    function() {
      // nodes
      if (!this.userApp.ui.selected.nodes?.length) {
        this.userApp.ui.selected.nodes.push({ id: this.getPageNodes(this.userApp)[0].id });
      }
      this.sui.node.selecteds = this.userApp.ui.selected.nodes.map(n => this.$root.findNodeByID(this.userApp, n));
      // page
      if (!this.userApp.ui.selected.page?.id) {
        const selectedPage = this.getSelectedPage(this.userApp);
        this.userApp.ui.selected.page = { id: selectedPage?.id };
      }
      this.sui.page.selected = this.$root.findNodeByID(this.userApp, this.userApp.ui.selected.page);
      // tool category
      this.sui.tool.category.index = this.userApp.ui.selected.tool.category.index;
      this.sui.tool.category.name = this.sui.tool.category.options[this.sui.tool.category.index]?.split(' ').last();
    }
  getPageNodes: | #js
    function() {
      return this.userApp.children.find(n => (n.type == "pages")).children;
    }
  getSelectedPage: | #js
    function(userApp) {
      const selectedNodes = userApp.ui.selected.nodes.map(this.$root.getNode);
      let selectedPage = selectedNodes.find(n => (n.type == "page"));
      if (!selectedPage) {
        const pages = userApp.children.find(n => (n.type == "pages"));
        selectedPage = pages.children[0];
      }
      return selectedPage;
    }
  do_navigate: | #js
    function(_do, node, nodeVar, toolCategoryIndex) {
      const actions = [];
      if (node) actions.push(this.do_select_node(_do, null, node));
      if (toolCategoryIndex) actions.push(this.do_select_tool_category(_do, toolCategoryIndex));
      const undos = actions.map(a => a.undo);
      this.setIconText(_do, node);
      return { _do, undos };
    }
  do_select_page: | #js
    function(_do, pageNode) {
      let oldPageNode = this.sui.page.selected;
      if ((!oldPageNode && !pageNode) || (oldPageNode?.id == pageNode?.id)) {
        this.userApp.ui.selected.page = null;
        return;
      }
      pageNode = this.$root.getNode(pageNode);
      this.userApp.ui.selected.page = (!pageNode ? null : { id: pageNode.id });
      this.sui.page.selected = pageNode;
      this.setIconText(_do, pageNode);
      const node = this.sui.node;
      node.hovered = node.selected = node.active = node.context = null;
      oldPageNode = this.onlyNodeID(oldPageNode);
      const undo = { type: "select.page", args: { pageNode: oldPageNode } };
      return { _do, undo };
    }
  do_select_node: | #js
    function(_do, selectIndex, node) {
      const selecteds = this.getSuiSelectedNodes();
      const oldSelectedNodes = selecteds.map(n => ({ id: n.id }));
      const oldSelectedPage = this.onlyNodeID(this.sui.page.selected);
      if (selectIndex == null) selectIndex = (selecteds.length);
      // clear anything above selectIndex
      selecteds.splice(selectIndex);
      node = this.$root.getNode(node);
      if (node) selecteds.push(node);
      this.userApp.ui.selected.nodes = selecteds.map(n => ({ id: n.id }));
      // if this is a page node, set sui.page.selected
      if (node?.type == "page") this.do_select_page(_do, node);
      this.setIconText(_do, node);
      const undo = { type: "select.nodes", args: { nodes: oldSelectedNodes } };
      this.$root.e.emit("sui.node.selecteds", selecteds);
      return { _do, undo };
    }
  do_select_tool_category: | #js
    function(_do, index) {
      const oldIndex = this.sui.tool.category.index;
      if (((!oldIndex) && (!index)) || (oldIndex == index)) return;
      const oldIcon = this.sui.tool.category.icons[oldIndex];
      const newIcon = this.sui.tool.category.icons[index];
      const name = this.sui.tool.category.options[index]?.split(' ').last();
      this.sui.tool.category.index = index;
      this.sui.tool.category.name = name;
      this.userApp.ui.selected.tool.category.index = index;
      _do.icon = newIcon;
      _do.text = name;
      const undo = { type: "select.tool.category", args: { index: oldIndex } };
      return { _do, undo };
    }
  do_select_nodes: | #js
    function(_do, nodes) {
      const selecteds = this.getSuiSelectedNodes();
      const oldSelectedNodes = selecteds.map(n => ({ id: n.id }));
      selecteds.splice(0);
      for (let i = 0; i < nodes.length; i++) {
        this.do_select_node(_do, i, nodes[i]);
      }
      this.userApp.ui.selected.nodes = selecteds.map(n => ({ id: n.id }));
      this.setIconText(_do, selecteds.last());
      const undo = { type: "select.nodes", args: { nodes: oldSelectedNodes } };
      return { _do, undo };
    }
  do_create_page: | #js
    function(_do, pageName) {
      const pageTemplatesNode = this.userApp.children.find(n => (n.type == "page.templates"));
      const pageTemplate = pageTemplatesNode.children.find(n => (n.name == "default"));
      const newPageNode = this.$root.createNewPageNode(this.userApp, pageName, "default");
      const action2 = this.do_select_node(_do, 0, newPageNode);
      this.setIconText(_do, newPageNode);
      const undo = { type: "delete.node", args: { node: { id: newPageNode.id } } };
      const undos = [undo, action2.undo];
      this.$root.e.emit("app.node.changed", this.userApp);
      return { _do, undos };
    }
  do_create_comp: | #js
    function(_do, contentNode, compName) {
      _do.args.contentNode = Objects.clone(contentNode);
      const parent = this.$root.getNodeParent(contentNode);
      const contentNodeIndex = parent.children.findIndex(n => (n.id == contentNode.id));
      const compsNode = this.userApp.children.find(n => (n.type == "comps"));
      let newCompNode = {
        type: "comp",
        name: compName,
      };
      newCompNode = this.$root.initNewNode(this.userApp, newCompNode);
      compsNode.children.push(newCompNode);
      TreeObject.moveNode(this.userApp, contentNode, newCompNode, { newTree: false });
      // insert a comp inst node instead of the content node
      const compInstName = this.$root.getNewNodeName(this.userApp, newCompNode.name);
      const compInstNode = {
        id: this.$root.getNewNodeID(this.userApp),
        type: "comp.inst",
        comp: { id: newCompNode.id, name: newCompNode.name },
        name: compInstName,
      };
      TreeObject.addNode(parent, compInstNode, contentNodeIndex);
      this.setIconText(_do, newCompNode, false, `📦 ${compInstName}`);
      const undo = { type: "uncreate.comp", args: { parent: { node: { id: parent.id } }, comp: { node: { id: newCompNode.id } }, index: contentNodeIndex } };
      this.$root.e.emit("app.node.changed", parent);
      this.$root.e.emit("new.comp.created", newCompNode);
      return { _do, undo };
    }
  do_uncreate_comp: | #js
    function(_do, parent, comp, index) {
      parent = this.$root.getNode(parent);
      comp = this.$root.getNode(comp);
      const compInst = parent.children[index];
      // delete the component instance node
      TreeObject.deleteNode(parent, compInst, { newTree: false });
      // remove the comp node from comps
      TreeObject.deleteNode(this.userApp, comp, { newTree: false });
      // unpack the comp back to [parent]
      const contentNode = Objects.clone(comp.children[0]);
      TreeObject.addNode(parent, contentNode, index);
      this.$root.e.emit("app.node.changed", parent);
    }
  do_create_node: | #js
    function(_do, selectIndex, parent, newNode) {
      newNode = Objects.clone(newNode);
      delete newNode._;
      parent = this.$root.getNode(parent);
      newNode = this.$root.initNewNode(this.userApp, newNode, { childOf: { parent, insertAt: 0 } });
      const action2 = this.do_select_node(_do, selectIndex, newNode);
      this.setIconText(_do, newNode);
      const undo = { type: "delete.node", args: { node: { id: newNode.id } } };
      const undos = [undo, action2.undo];
      this.$root.e.emit("app.node.changed", parent);
      return { _do, undos };
    }
  do_move_node: | #js
    function(_do, node, parent, newIndex) {
      parent = this.$root.getNode(parent);
      node = this.$root.getNode(node);
      const oldParent = this.$root.getNodeParent(node);
      const oldIndex = oldParent.children.findIndex(n => (n.id == node.id));
      if (newIndex == null) newIndex = parent.children.length;
      TreeObject.moveNode(this.userApp, node, parent, newIndex);
      this.setIconText(_do, parent, true, node);
      const undo = { type: "move.node", args: { node: { id: node.id }, parent: { id: oldParent.id }, newIndex: oldIndex } };
      this.$root.e.emit("app.node.changed", parent);
      return { _do, undo };
    }
  do_delete_node: | #js
    function(_do, node) {
      node = this.$root.getNode(node);
      let parent = this.$root.getNodeParent(node);
      const index = parent.children.findIndex(n => (n.id == node.id));
      parent = { node: { id: parent.id } };
      TreeObject.deleteNode(this.userApp, node, { newTree: false });
      this.setIconText(_do, parent);
      const undo = { type: "undelete.node", args: { parent, node, index } };
      this.$root.e.emit("app.node.changed", parent.node);
      return { _do, undo };
    }
  do_edit_node: | #js
    function(_do, oldNode, newNode, changes) {
      oldNode = Objects.clone(oldNode, { exclude: ["children"] });
      newNode = Objects.clone(newNode, { exclude: ["children"] });
      let undoChanges = [];
      if (oldNode && newNode) {
        if (!newNode.id) {
          const newNode2 = Objects.clone(newNode);
          newNode = Objects.clone(oldNode, { exclude: ["children"] });
          Objects.deepAssign(newNode, newNode2);
        }
        delete oldNode.children;
        delete newNode.children;
        changes = DeepDiff.diff(oldNode, newNode);
        undoChanges = DeepDiff.diff(newNode, oldNode);
        if (!changes) return alertify.error("No changes detected");
      }

      let node = this.$root.getNode(oldNode);

      // if comp name changed, update comp inst names
      if ((node.type == "comp") && (changes.length == 1) && (Objects.areEqual(changes[0].path, ["name"]))) {
        const compInsts = TreeObject.filter(this.userApp, (n) => (n.type == "comp.inst" && n.comp.id == oldNode.id));
        const newName = changes[0].rhs;
        for (const compInst of compInsts) {
          compInst.comp.name = newName;
          this.$root.appNodeChanged(compInst);
        }
      }

      const prevNode = Objects.clone(node, { exclude: ["children"] });
      for (const change of changes) DeepDiff.applyChange(node, change);
      if (!undoChanges.length) {
        const node2 = Objects.clone(node, { exclude: ["children"] });
        undoChanges = DeepDiff.diff(node2, prevNode);
      }
      _do = { type: "edit.node", args: { node, newNode: null, changes } };
      this.setIconText(_do, node, true, this.getActionInfo(changes));
      const undo = { type: "edit.node", args: { node: { id: node.id }, newNode: null, changes: undoChanges } };
      this.$root.appNodeEdited(node);
      return { _do, undo };
    }
  getActionInfo: | #js
    function(changes) {
      let info = (changes[0].item?.rhs?.type ?? changes[0].item?.rhs ?? changes[0].rhs);
      if ((typeof info == "object")) info = null;
      return info;
    }
  do_edit_node_var: | #js
    function(_do, node, varName, key, value) {
      node = this.$root.getNode(node);
      const oldNode = Objects.clone(node, { exclude: ["children"] });
      const nodeVar = node.vars.find(v => (v.name == varName));
      const oldValue = Objects.clone(nodeVar[key]);
      nodeVar[key] = value;
      const newNode = Objects.clone(node);
      const editNodeAction = this.do_edit_node(_do, oldNode, newNode, null);
      if (!editNodeAction._do) return;
      this.setIconText(_do, node, true, editNodeAction._do.info);
      const undo = { type: "edit.node.var", args: { node: { id: node.id }, varName, key, value: oldValue } };
      this.$root.appNodeChanged(node);
      return { _do, undo };
    }
  do_undelete_node: | #js
    function(_do, parent, node, index) {
      parent = this.$root.getNode(parent);
      TreeObject.addNode(parent, node, index);
      const undo = { type: "delete.node", args: { node: { id: node.id } } };
      this.$root.e.emit("app.node.changed", parent);
      return { _do, undo };
    }
  undo: | #js
    function() {
      if (this.pointerToLocalIndex(this.pointer) < 0) {
        return alertify.error("Nothing to undo");
      }
      const action = this.getAction(this.pointer);
      if (action.undo) this.do(action.undo, false);
      if (action.undos) for (const undo of action.undos) this.do(undo, false);
      this.pointer--;
      this.$root.e.emit("action.undo", action);
    }
  redo: | #js
    function() {
      if (this.pointer >= this.actions.last()?._i) return alertify.error("Nothing to redo");
      this.pointer++;
      const action = this.getAction(this.pointer);
      this.do(action.do, false);
      this.$root.e.emit("action.redo", action);
    }
  do: | #js
    function(_do, addToStack = true) {
      const doMethod = this[`do_${_do.type.replace(/\./g, "_")}`];
      if (!doMethod) return alertify.error(`Action type not implemented: ${doAction.type}`);

      const action = doMethod(_do, ...Object.values(_do.args));
      if (!addToStack || !action) return;
      action.undos = (action.undos ?? []);
      if (action.undo) action.undos.unshift(action.undo);
      delete action.undo;

      this.addAction(action);
      //this.$root.studio.user.app.log(this, `🖱️`, "do", { action });
    }
  _do: | #js
    function(type, args, addToStack = true) {
      this.do({ type, args }, addToStack);
    }
  getLastGroupableAction: | #js
    function(action) {
      const prev = this.actions.last();
      if (!prev) return null;
      if (action.do.type != prev.do.type) return null;
      const type = prev.undos[0].type;
      const prevArgs = prev.undos[0].args;
      const args = action.do.args;
      if (type == "edit.node") {
        if (prevArgs.node.id == args.node.id) return prev;
      }
      if (type == "edit.node.var") {
        if (prevArgs.node.id == args.node.id) {
          if (prevArgs.varName == args.varName) {
            if ([(typeof prevArgs.value), (typeof args.value)].includes("string")) {
              return prev;
            }
          }
        }
      }
      return null;
    }
  addAction: | #js
    function(action) {
      const localPointer = this.pointerToLocalIndex(this.pointer);
      action.id = (this.actions.last()?.id ?? 0) + 1;
      if (this.pointer < this.actions.last()?._i) {
        this.actions.splice(localPointer + 1);
      }
      if (action._do) {
        action.do = action._do;
        delete action._do;
      }
      // group with previous edit, if any
      // by deleting the previous edit action and merging its changes
      const prevAction = this.getLastGroupableAction(action);
      if (prevAction) {
        action.undos.shift();
        action.undos.unshift(prevAction.undos.first());
        this.actions.pop();
        this.pointer--;
      }
      action._i = (this.actions.last()?._i ?? -1) + 1;
      this.actions.add(action);
      this.pointer++;
      this.refresh();
    }
  setIconText: | #js
    function(_do, node, shortenNodeRefs = true, info = null) {
      _do.icon = this.$root.getNodeIcon(node);
      _do.text = this.$root.getNodeText(node);
      // find any node props in _do.args (has [id] and [type]) and keep only their { id: [id] }
      if (shortenNodeRefs) {
        for (const key in _do.args) {
          const value = _do.args[key];
          if (value?.id && value?.type) _do.args[key] = { id: value.id };
        }
      }
      if (info) {
        if (info.id) {
          const node2 = info;
          _do.info = `${this.$root.getNodeIcon(node2)} ${this.$root.getNodeText(node2)}`;
        }
        else {
          _do.info = info;
        }
      }
    }
  getAction: | #js
    function(index) {
      return this.actions.find(a => (a._i == index));
    }
  getSuiSelectedNodes: | #js
    function() {
      this.sui.node.selecteds = this.sui.node.selecteds.filter(n => n);
      return this.sui.node.selecteds;
    }
  pointerToLocalIndex: | #js
    function(pointer) {
      return this.actions.findIndex(a => (a._i == pointer));
    }
  refresh: | #js
    function() {
      this.key1++;
    }
  onlyNodeID: | #js
    function(node) {
      return (!node) ? null : { id: node.id };
    }

watch:
  pointer: | #js
    function(newPointer) {
      this.refresh();
    }

style:
  h3:
    white-space: nowrap
