dom:
  div:
    v-if: false
    .flex.justify-center:
      button:
        v-text: "'⤺'"
        @click: undo
      button:
        v-text: "'⤻'"
        @click: redo
    studio.app.action.stack.list:
      :actions: actions
      :pointer: pointer

props:
  userApp:
  sui:

data:
  actions: []
  pointer: -1
  remote:
    actions:
    pointer:

mounted: | #js
  async function() {
    this.$root.do = this._do.bind(this);
    // ctrl + z, ctrl + y
    window.addEventListener("keydown", (e) => {
      // ignore events from [input] and [textarea]
      if ([ "input", "textarea" ].includes(e.target.tagName.toLowerCase())) return;
      if (e.ctrlKey && e.key == "z") this.undo();
      if (e.ctrlKey && e.key == "y") this.redo();
    });

    this.remote.actions = await this.$root.data.array("Actions", this.actions);
    this.remote.pointer = await this.$root.data.vue.reactive("Pointers", this, "pointer", -1);
    this.pointer = -1;
  }

methods:
  do_select_page: | #js
    function(_do, pageNode) {
      let oldPageNode = this.sui.page.selected;
      if ((!oldPageNode && !pageNode) || (oldPageNode?.id == pageNode?.id)) return;
      pageNode = this.$root.getNode(pageNode);
      this.sui.page.selected = pageNode;
      this.setIconText(_do, pageNode);
      const node = this.sui.node;
      node.hovered = node.selected = node.active = node.context = null;
      oldPageNode = this.onlyNodeID(oldPageNode);
      const undo = { type: "select.page", args: { pageNode: oldPageNode } };
      return { _do, undo };
    }
  do_select_tool_category: | #js
    function(_do, index) {
      const oldIndex = this.sui.tool.category.index;
      if (((!oldIndex) && (!index)) || (oldIndex == index)) return;
      const oldIcon = this.sui.tool.category.icons[oldIndex];
      const newIcon = this.sui.tool.category.icons[index];
      const name = this.sui.tool.category.options[index]?.split(' ').last();
      this.sui.tool.category.index = index;
      this.sui.tool.category.name = name;
      _do.icon = newIcon;
      _do.text = name;
      const undo = { type: "select.tool.category", args: { index: oldIndex } };
      return { _do, undo };
    }
  do_select_node: | #js
    function(_do, selectIndex, node) {
      if (!node) return;
      const selecteds = this.sui.node.selecteds;
      const oldSelectedNodes = selecteds.map(n => ({ id: n.id }));
      const oldSelectedPage = this.onlyNodeID(this.sui.page.selected);
      // clear anything above selectIndex
      selecteds.splice(selectIndex);
      node = this.$root.getNode(node);
      selecteds.push(node);
      // if this is a page node, set sui.page.selected
      if (node?.type == "page") this.do_select_page(_do, node);
      this.setIconText(_do, node);
      const undo = { type: "select.nodes", args: { page: oldSelectedPage, nodes: oldSelectedNodes } };
      this.$root.e.emit("sui.node.selecteds", selecteds);
      return { _do, undo };
    }
  do_select_nodes: | #js
    function(_do, page, nodes) {
      const selecteds = this.sui.node.selecteds;
      const oldSelectedNodes = selecteds.map(n => ({ id: n.id }));
      selecteds.splice(0);
      for (let node of nodes) {
        node = this.$root.getNode(node);
        selecteds.push(node);
      }
      const lastNode = selecteds.pop();
      this.do_select_node(_do, selecteds.length, lastNode);
      this.do_select_page(_do, page);
      this.setIconText(_do, selecteds.last());
      const undo = { type: "select.nodes", args: { nodes: oldSelectedNodes } };
      return { _do, undo };
    }
  do_create_comp: | #js
    function(_do, contentNode) {
      _do.args.contentNode = Objects.clone(contentNode);
      const parent = this.$root.getNodeParent(contentNode);
      const contentNodeIndex = parent.children.findIndex(n => (n.id == contentNode.id));
      const compsNode = this.userApp.children.find(n => (n.type == "comps"));
      let newCompNode = {
        type: "comp",
        name: null,
      };
      newCompNode = this.$root.initNewNode(this.userApp, newCompNode);
      compsNode.children.push(newCompNode);
      TreeObject.moveNode(this.userApp, contentNode, newCompNode, { newTree: false });
      // insert a comp inst node instead of the content node
      const compInstNode = {
        id: this.$root.getNewNodeID(this.userApp),
        type: "comp.inst",
        comp: { id: newCompNode.id, name: newCompNode.name },
      };
      TreeObject.addNode(parent, compInstNode, contentNodeIndex);
      this.setIconText(_do, newCompNode, false);
      const undo = { type: "uncreate.comp", args: { parent: { node: { id: parent.id } }, comp: { node: { id: newCompNode.id } }, index: contentNodeIndex } };
      this.$root.e.emit("new.comp.created", newCompNode);
      return { _do, undo };
    }
  do_uncreate_comp: | #js
    function(_do, parent, comp, index) {
      parent = this.$root.getNode(parent);
      comp = this.$root.getNode(comp);
      const compInst = parent.children[index];
      // delete the component instance node
      TreeObject.deleteNode(parent, compInst, { newTree: false });
      // remove the comp node from comps
      TreeObject.deleteNode(this.userApp, comp, { newTree: false });
      // unpack the comp back to [parent]
      const contentNode = Objects.clone(comp.children[0]);
      TreeObject.addNode(parent, contentNode, index);
      this.$root.e.emit("app.node.changed", parent);
    }
  do_create_node: | #js
    function(_do, parent, newNode) {
      newNode = Objects.clone(newNode);
      delete newNode._;
      parent = this.$root.getNode(parent);
      newNode = this.$root.initNewNode(this.userApp, newNode, { childOf: { parent, insertAt: 0 } });
      this.sui.node.selected = newNode;
      this.setIconText(_do, newNode);
      const undo = { type: "delete.node", args: { node: { id: newNode.id } } };
      this.$root.e.emit("app.node.changed", parent);
      return { _do, undo };
    }
  do_delete_node: | #js
    function(_do, node) {
      node = this.$root.getNode(node);
      let parent = this.$root.getNodeParent(node);
      const index = parent.children.findIndex(n => (n.id == node.id));
      parent = { node: { id: parent.id } };
      TreeObject.deleteNode(this.userApp, node, { newTree: false });
      this.setIconText(_do, parent);
      const undo = { type: "undelete.node", args: { parent, node, index } };
      this.$root.e.emit("app.node.changed", parent.node);
      return { _do, undo };
    }
  do_edit_node: | #js
    function(_do, oldNode, newNode, changes, isFirstTime) {
      let undoChanges = [];
      if (oldNode && newNode) {
        delete oldNode.children;
        delete newNode.children;
        changes = DeepDiff.diff(oldNode, newNode);
        undoChanges = DeepDiff.diff(newNode, oldNode);
        if (!changes) return alertify.error("No changes detected");
      }

      if (isFirstTime) {
        // group with previous edit, if any
        const prevAction = this.actions.last();
        if (prevAction?.do.type == "edit.node") {
          if (prevAction.do.args.node.id == oldNode.id) {
            undoChanges = prevAction.undo.args.changes;
            this.actions.pop();
          }
        }
      }

      let node = this.$root.getNode(oldNode);

      if ((node.type == "comp") && (changes.length == 1) && (Objects.areEqual(changes[0].path, ["name"]))) {
        // if comp name changed, update comp inst names
        const compInsts = TreeObject.filter(this.userApp, (n) => (n.type == "comp.inst" && n.comp.id == oldNode.id));
        const newName = changes[0].rhs;
        for (const compInst of compInsts) {
          compInst.comp.name = newName;
          this.$root.appNodeChanged(compInst);
        }
      }

      const prevNode = Objects.clone(node, { exclude: ["children"] });
      for (const change of changes) DeepDiff.applyChange(node, change);
      if (!undoChanges.length) {
        const node2 = Objects.clone(node, { exclude: ["children"] });
        undoChanges = DeepDiff.diff(node2, prevNode);
      }
      _do = { type: "edit.node", args: { node, newNode: null, changes } };
      this.setIconText(_do, node);
      const undo = { type: "edit.node", args: { node: { id: node.id }, newNode: null, changes: undoChanges } };
      this.$root.appNodeEdited(node);
      return { _do, undo };
    }
  do_edit_node_var: | #js
    function(_do, node, varName, key, value) {
      node = this.$root.getNode(node);
      const oldNode = Objects.clone(node, { exclude: ["children"] });
      const nodeVar = node.vars.find(v => (v.name == varName));
      const oldValue = Objects.clone(nodeVar[key]);
      nodeVar[key] = value;
      const newNode = Objects.clone(node);
      this.do_edit_node(_do, oldNode, newNode, null);
      this.$root.do("edit.node", { oldNode, newNode, changes: null }, false)
      this.setIconText(_do, node);
      const undo = { type: "edit.node.var", args: { node: { id: node.id }, varName, key, value: oldValue } };
      this.$root.appNodeChanged(node);
      return { _do, undo };
    }
  do_undelete_node: | #js
    function(_do, parent, node, index) {
      parent = this.$root.getNode(parent);
      TreeObject.addNode(parent, node, index);
      const undo = { type: "delete.node", args: { node: { id: node.id } } };
      this.$root.e.emit("app.node.changed", parent);
      return { _do, undo };
    }
  replay: | #js
    function(from, to) {
      for (let i = from; i <= to; i++) {
        const action = this.actions[i];
        this.do(action.do, false);
      }
    }
  undo: | #js
    function() {
      if (this.pointer < 0) return alertify.error("Nothing to undo");
      const action = this.actions[this.pointer];
      this.do(action.undo, false);
      this.pointer--;
    }
  redo: | #js
    function() {
      if (this.pointer >= (this.actions.length - 1)) return alertify.error("Nothing to redo");
      this.pointer++;
      const action = this.actions[this.pointer];
      this.do(action.do, false);
    }
  do: | #js
    function(_do, addToStack = true) {
      const isFirstTime = (addToStack);
      const doMethod = this[`do_${_do.type.replace(/\./g, "_")}`];
      if (!doMethod) return alertify.error(`Action type not implemented: ${doAction.type}`);
      const action = doMethod(_do, ...Object.values(_do.args), isFirstTime);
      if (!addToStack || !action) return;
      this.addAction(action);
      //this.$root.studio.user.app.log(this, `🖱️`, "do", { action });
    }
  _do: | #js
    function(type, args, addToStack = true) {
      this.do({ type, args }, addToStack);
    }
  addAction: | #js
    function(action) {
      if (this.pointer < (this.actions.length - 1)) {
        this.actions.splice(this.pointer + 1);
      }
      const actionIndex = this.actions.length;
      const actionID = ((this.actions.last()?.id ?? 0) + 1);
      action._i = actionIndex;
      action.id = actionID;
      if (action._do) {
        action.do = action._do;
        delete action._do;
      }
      this.actions.add(action);
      this.pointer = (this.actions.length - 1);
    }
  setIconText: | #js
    function(_do, node, shortenNodeRefs = true) {
      _do.icon = this.$root.getNodeIcon(node);
      _do.text = this.$root.getNodeText(node);
      // find any node props in _do.args (has [id] and [type]) and keep only their { id: [id] }
      if (shortenNodeRefs) {
        for (const key in _do.args) {
          const value = _do.args[key];
          if (value?.id && value?.type) _do.args[key] = { id: value.id };
        }
      }
    }
  onlyNodeID: | #js
    function(node) {
      return (!node) ? null : { id: node.id };
    }
