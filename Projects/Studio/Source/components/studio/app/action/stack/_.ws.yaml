dom:
  div:
    v-if: false
    .flex.justify-center:
      button:
        v-text: "'⤺'"
        @click: undo
      button:
        v-text: "'⤻'"
        @click: redo
    studio.app.action.stack.list:
      :actions: actions
      :pointer: pointer

props:
  userApp:
  sui:

data:
  actions: []
  pointer: -1
  remote:
    actions:
    pointer:

mounted: | #js
  function() {
    this.$root.do = this._do.bind(this);
    // ctrl + z, ctrl + y
    window.addEventListener("keydown", (e) => {
      if (e.ctrlKey && e.key == "z") this.undo();
      if (e.ctrlKey && e.key == "y") this.redo();
    });

    const remoteStore = (new Data2.Browser.LocalStorage());
    this.remote.actions = remoteStore.array("actions", this.actions);
    this.remote.pointer = remoteStore.vue.reactive(this, "pointer", -1);
  }

methods:
  do_select_page: | #js
    function(_do, pageNode) {
      let oldPageNode = this.sui.page.selected;
      if ((!oldPageNode && !pageNode) || (oldPageNode?.id == pageNode?.id)) return;
      pageNode = this.$root.getNode(pageNode);
      this.sui.page.selected = pageNode;
      this.setIconText(_do, pageNode);
      const node = this.sui.node;
      node.hovered = node.selected = node.active = node.context = null;
      oldPageNode = this.onlyNodeID(oldPageNode);
      const undo = { type: "select.page", args: { pageNode: oldPageNode } };
      return { _do, undo };
    }
  do_select_tool_category: | #js
    function(_do, index) {
      const oldIndex = this.sui.tool.category.index;
      if (((!oldIndex) && (!index)) || (oldIndex == index)) return;
      const oldIcon = this.sui.tool.category.icons[oldIndex];
      const newIcon = this.sui.tool.category.icons[index];
      const name = this.sui.tool.category.options[index]?.split(' ').last();
      this.sui.tool.category.index = index;
      this.sui.tool.category.name = name;
      _do.icon = newIcon;
      _do.text = name;
      const undo = { type: "select.tool.category", args: { index: oldIndex } };
      return { _do, undo };
    }
  do_select_node: | #js
    function(_do, selectIndex, node) {
      if (!node) return;
      const selecteds = this.sui.node.selecteds;
      const oldSelectedNodes = selecteds.map(n => ({ id: n.id }));
      const oldSelectedPage = this.onlyNodeID(this.sui.page.selected);
      // clear anything above selectIndex
      selecteds.splice(selectIndex);
      node = this.$root.getNode(node);
      selecteds.push(node);
      // if this is a page node, set sui.page.selected
      if (node?.type == "page") this.do_select_page(_do, node);
      this.setIconText(_do, node);
      const undo = { type: "select.nodes", args: { page: oldSelectedPage, nodes: oldSelectedNodes } };
      return { _do, undo };
    }
  do_select_nodes: | #js
    function(_do, page, nodes) {
      const selecteds = this.sui.node.selecteds;
      const oldSelectedNodes = selecteds.map(n => ({ id: n.id }));
      selecteds.splice(0);
      for (let node of nodes) {
        node = this.$root.getNode(node);
        selecteds.push(node);
      }
      const lastNode = selecteds.pop();
      this.do_select_node(_do, selecteds.length, lastNode);
      this.do_select_page(_do, page);
      this.setIconText(_do, selecteds.last());
      const undo = { type: "select.nodes", args: { nodes: oldSelectedNodes } };
      return { _do, undo };
    }
  do_create_node: | #js
    function(_do, parent, newNode) {
      delete newNode._;
      parent = this.$root.getNode(parent);
      newNode = this.$root.initNewNode(this.userApp, newNode, { childOf: { parent, insertAt: 0 } });
      this.sui.node.selected = newNode;
      this.setIconText(_do, newNode);
      const undo = { type: "delete.node", args: { node: { id: newNode.id } } };
      this.$root.$emit("app.node.changed", parent);
      return { _do, undo };
    }
  do_delete_node: | #js
    function(_do, node) {
      node = this.$root.getNode(node);
      let parent = this.$root.getNodeParent(node);
      const index = parent.children.findIndex(n => (n.id == node.id));
      parent = { node: { id: parent.id } };
      TreeObject.deleteNode(this.userApp, node, { newTree: false });
      this.setIconText(_do, parent);
      const undo = { type: "undelete.node", args: { parent, node, index } };
      this.$root.$emit("app.node.changed", parent.node);
      return { _do, undo };
    }
  do_edit_node: | #js
    function(_do, oldNode, newNode, changes) {
      let undoChanges = [];
      if (oldNode && newNode) {
        delete oldNode.children;
        delete newNode.children;
        changes = DeepDiff.diff(oldNode, newNode);
        undoChanges = DeepDiff.diff(newNode, oldNode);
        if (!changes) throw "No changes detected";
      }
      let node = this.$root.getNode(oldNode);
      const prevNode = Objects.clone(node, { exclude: ["children"] });
      for (const change of changes) DeepDiff.applyChange(node, change);
      if (!undoChanges.length) {
        const node2 = Objects.clone(node, { exclude: ["children"] });
        undoChanges = DeepDiff.diff(node2, prevNode);
      }
      _do = { type: "edit.node", args: { node, newNode: null, changes } };
      this.setIconText(_do, node);
      const undo = { type: "edit.node", args: { node: { id: node.id }, newNode: null, changes: undoChanges } };
      this.$root.appNodeEdited(node);
      return { _do, undo };
    }
  do_edit_node_var: | #js
    function(_do, node, varName, key, value) {
      node = this.$root.getNode(node);
      const oldNode = Objects.clone(node, { exclude: ["children"] });
      const nodeVar = node.vars.find(v => (v.name == varName));
      const oldValue = Objects.clone(nodeVar[key]);
      nodeVar[key] = value;
      const newNode = Objects.clone(node);
      this.$root.do("edit.node", { oldNode, newNode })
      this.setIconText(_do, node);
      const undo = { type: "edit.node.var", args: { node: { id: node.id }, varName, key, value: oldValue } };
      return { _do, undo };
    }
  do_undelete_node: | #js
    function(_do, parent, node, index) {
      parent = this.$root.getNode(parent);
      TreeObject.addNode(parent, node, index);
      const undo = { type: "delete.node", args: { node: { id: node.id } } };
      this.$root.$emit("app.node.changed", parent);
      return { _do, undo };
    }
  undo: | #js
    function() {
      if (this.pointer < 0) return alertify.error("Nothing to undo");
      const action = this.actions[this.pointer];
      this.do(action.undo, false);
      this.pointer--;
    }
  redo: | #js
    function() {
      if (this.pointer >= (this.actions.length - 1)) return alertify.error("Nothing to redo");
      this.pointer++;
      const action = this.actions[this.pointer];
      this.do(action.do, false);
    }
  do: | #js
    function(_do, addToStack = true) {
      const doMethod = this[`do_${_do.type.replace(/\./g, "_")}`];
      if (!doMethod) return alertify.error(`Action type not implemented: ${doAction.type}`);
      const action = doMethod(_do, ...Object.values(_do.args));
      if (!addToStack || !action) return;
      this.addAction(action);
    }
  _do: | #js
    function(type, args) {
      this.do({ type, args });
    }
  addAction: | #js
    function(action) {
      if (this.pointer < (this.actions.length - 1)) {
        this.actions.splice(this.pointer + 1);
      }
      const actionIndex = this.actions.length;
      const actionID = ((this.actions.last()?.id ?? 0) + 1);
      action._i = actionIndex;
      action.id = actionID;
      if (action._do) {
        action.do = action._do;
        delete action._do;
      }
      this.actions.add(action);
      this.pointer = (this.actions.length - 1);
    }
  setIconText: | #js
    function(_do, node) {
      _do.icon = this.$root.getNodeIcon(node);
      _do.text = this.$root.getNodeText(node);
      // find any node props in _do.args (has [id] and [type]) and keep only their { id: [id] }
      for (const key in _do.args) {
        const value = _do.args[key];
        if (value?.id && value?.type) _do.args[key] = { id: value.id };
      }
    }
  onlyNodeID: | #js
    function(node) {
      return (!node) ? null : { id: node.id };
    }
