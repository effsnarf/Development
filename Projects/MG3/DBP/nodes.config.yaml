title:
admin:
  ips:
    - 127.0.0.1
    - ::1
    - 89.134.7.165
    - 2a02:ab88:c8b:fb00:a4d4:ea7:170e:ce50
server:
  host: localhost
  port:
  cors:
    dev: [localhost, localhost:5051]
    prod: [memegenerator.net, localhost, localhost:5051]
  # on dev, we're relaying requests to the production dbp/db
  proxy:
    dev: db.memegenerator.net
database:
  connectionString: mongodb://localhost:27017
  query:
    max:
      docs: 50
analytics:
  min:
    elapsed: 50
  database:
    prod:
      write:
        path: F:\Database\MG-Analytics
      read:
        connectionString: mongodb://localhost:47017
        database: MG-Analytics
severity:
  time: [50, 500, "<"]
log:
  debug:
    path: (env) => env.getLogPath(env.config.title, "debug")
  errors:
    path: (env) => env.getLogPath(env.config.title, "errors")
requests:
  severity:
    time: [100, 500, "<"]
dbs:
  IDE:
    users:
      enabled: true
  MemeGenerator:
    users:
      enabled: false
restart:
  url: /restart/Jz0xnwG1bDv57LFpKTS6UkV8h9XQtCeBOMl2NHfRIj3yPcZYimAsrqdV4oWEaFhu
api:
  methods:
    Builders.select.one:
      args: [urlName]
      code: | #js
        const builder = await db.findOne("Builders", { UrlName: urlName });
        return builder;
    Builders.select.all:
      args: []
      code: | #js
        const builders = await db.find("Builders", { }, { }, 100, undefined, true);
        return builders;
    Medias.create.one:
      args: [media]
      code: | #js
        if (!media) throw new Error("Argument missing: media");
        const existingMedia = await db.findOne("Medias", { _uid: media._uid });
        if (existingMedia) return existingMedia;
        media = await db.upsert("Medias", media, true);
        return media;
    Medias.select.one:
      args: [mediaID]
      code: | #js
        const uid = (typeof mediaID != "string") ? null : mediaID;
        const media = uid ?
          await db.findOne("Medias", { _uid: mediaID }) :
          await db.findOne("Medias", { _id: mediaID });
        return media;
    Medias.select.new:
      args: [builderID, fromMediaID]
      code: | #js
        if (!builderID) throw new Error("Argument missing: builderID");
        if (!fromMediaID) fromMediaID = Number.MAX_VALUE;
        const pageSize = 15;
        const medias = await db.find("Medias", { BuilderID: builderID, _id: { $lt: fromMediaID } }, { _id: -1 }, pageSize, 0, true);
        return medias;
    Medias.delete.one:
      admin: true
      args: [mediaID]
      code: | #js
        await db.delete("Medias", { _id: mediaID });
        return true;
    Generators.select.search:
      args: [query]
      code: | #js
        const pageIndex = 0;
        const pageSize = 15;
        const regex = new RegExp(query, "i");
        const filter = (!query) ? {} : { DisplayName: regex };
        var gens = (await db.find('Generators', filter, { InstancesCount: -1 }, pageSize, (pageIndex * pageSize), true));
        return gens;
    Generators.select.related:
      args: [urlName]
      code: | #js
        if (!urlName) return [];

        if (urlName == "Forever-Alone")
        {
          const gens = [await db.findOne("Generators", { UrlName: "Depression-Dog" })];
          return gens;
        }

        if (urlName == "Socially-Awkward-Penguin") {
          const displayName = urlName.replace(/-/g, ' ');
          const regex = new RegExp(`penguin`, 'gi');
          var gens = await db.find('Generators', { DisplayName: { $regex: regex, $ne: displayName } }, { InstancesCount: -1 }, 10, 0, true);
          return gens;
        }

        var gen = (await db.findOne('Generators', { UrlName: urlName }));

        if (!gen) return [];

        var displayName = gen.displayName;
        var words = displayName.split(' ');
        var regex = new RegExp(`(${words.join("|")})`, 'gi');
        var gens = await db.find('Generators', { DisplayName: { $regex: regex, $ne: displayName } }, { InstancesCount: -1 }, 10, 0, true);

        return gens;
    Generators.sample.popular:
      args: [count]
      code: | #js
        let gens = (await db.aggregate("Generators",
          [
            { $match: { IsQuality: true, "Desc.Article": { $exists: true } } },
            { $sample: { size: count * 2 } }
          ]
        ));

        const genNames = gens.map(g => g.UrlName).distinct();

        gens = genNames
          .take(count)
          .map(g => gens.first(gg => gg.UrlName == g));

        return gens;
    Instances.delete.one:
      admin: true
      args: [instanceID]
      code: | #js
        await db.delete("Instances", { _id: instanceID });
    Instances.sample.popular:
      args: [urlName, count]
      code: | #js
        if (!urlName)
        {
          if (false)
          {
            const commentEntities = await db.find("CommentEntities", { }, { CommentsCount: -1 }, 100, undefined, true);
            const ids = commentEntities.take(count).map(c => c.entityID);
            const insts = await db.find("Instances", { _id: { $in: ids } }, { }, count, undefined, true);
            return insts;
          }

          const gens = await db.find("Generators", { IsQuality: true }, {}, 100, undefined, true);
          const genIDs = gens.shuffle().take(count).map(g => g._id);

          const getOneInstance = async (genID, minScore) => {
            const instances = (await db.aggregate("Instances",
              [
                { $match: { LanguageCode: "en", GeneratorID: genID, TotalVotesScore: { $gt: minScore } } },
                { $sample: { size: 1 } }
              ]
            ));
            return instances[0];
          };

          const getGoodInstance = async (genID) => {
            for (const score of [20, 10, 5, 0])
            {
              const instance = await getOneInstance(genID, score);
              if (instance) return instance;
            }
          };

          const instances = await Promise.all(genIDs.map(async (gid) => await getGoodInstance(gid)));

          return instances;
        }

        const gen = await db.findOne("Generators", { UrlName: urlName });

        const instances = await db.aggregate("Instances",
          [
            { $match: { LanguageCode: "en", GeneratorID: gen._id, TotalVotesScore: { $gt: 20 } } },
            { $sample: { size: count } }
          ]
        );

        return instances;
    Instances.select.popular:
      args: [languageCode, pageIndex, urlName]
      code: | #js
        const pageSize = 15;
        const skip = pageIndex * pageSize;

        if (!urlName) {
          return await db.aggregate(
            'Instances',
            [
              {
                $match: {
                  LanguageCode: "en",
                  TotalVotesScore: { $gt: 30 }
                }
              },
              { $sample: { size: pageSize } }
            ],
            true
          );
        }

        const gens = (await db.find('Generators', { UrlName: urlName }, {}, 1));

        if (!gens.length) return [];

        const gen = gens[0];

        const insts = await db.find(
          'Instances',
          { LanguageCode: languageCode, GeneratorID: gen._id },
          { TotalVotesScore: -1 },
          pageSize,
          skip,
          true
        );

        return insts;
    Instances.select.one:
      args: [instanceID]
      code: | #js
        const instance = await db.findOne("Instances", { _id: instanceID });
        return instance;
    Instances.create.one:
      args: [languageCode, generatorID, imageID, text0, text1]
      code: | #js
        if (null == generatorID) throw new Error("GeneratorID is required");

        let existingInstance = await db.findOne("Instances", { GeneratorID: generatorID, Text0: text0, Text1: text1 });
        if (existingInstance) return existingInstance;

        const now = (new Date());
        const nowDate = (new Date());
        nowDate.setHours(0, 0, 0, 0);
        const generator = await db.findOne("Generators", { _id: generatorID });
        if (!generator) throw new Error("Generator not found");
        let instance = {
          LanguageCode: languageCode,
          MgUserID: null,
          GeneratorID: generatorID,
          UrlName: generator.urlName,
          UrlName_Lowercase: generator.urlName.toLowerCase(),
          DisplayName: generator.displayName,
          ImageID: generator.imageID,
          Text0: text0,
          Text1: text1,
          Text: [text0, text1].filter(a => a).join(" "),
          UpVotesScore: 0,
          DownVotesScore: 0,
          TotalVotesScore: 0,
          Created: now,
          CreatedDate: nowDate,
        };
        instance = await db.upsert("Instances", instance, true);
        instance.InstanceID = instance._id;
        await db.upsert("Instances", instance, true);
        return instance;
    Threads.create.one:
      args: [threadMediaID]
      code: | #js
        let thread = {
          PostsCount: 0,
          Created: Date.now(),
        };
        thread = await db.upsert("Threads", thread, true);
        const threadMedia = (!threadMediaID ? null : (await db.findOne("Medias", { _id: threadMediaID })) );
        if (threadMedia)
        {
          const firstPost = await dbp.posts.create.one(thread._id, null, null, null, threadMedia);
        }
        return thread;
    Threads.select.one:
      args: [threadID, threadMediaID]
      code: | #js
        if (!threadID)
        {
          if (threadMediaID)
          {
            const firstPost = await db.findOne("Posts", { "Media._id": threadMediaID });
            if (firstPost) threadID = firstPost.threadID;
          }
        }
        const thread = await db.findOne("Threads", { _id: threadID });
        if (!thread) return null;
        thread.posts = await db.find("Posts", { ThreadID: thread._id }, { Index: 1 }, 1000, null, true);
        return thread;
    Threads.select.all:
      args: []
      code: | #js
        return [];
        let threads = await db.find("Threads", {}, { LastPostCreated: -1 }, 1000, null, true);
        threads = await Promise.all(threads.map(async t => await dbp.threads.select.one(t._id)));
        return threads;
    Posts.create.one:
      args: [threadID, threadMediaID, text, instance, media, imageID]
      code: | #js
        const now = Date.now();

        let thread = null;
        thread = await dbp.threads.select.one(threadID, threadMediaID);
        if (!thread) thread = await dbp.threads.create.one(threadMediaID);
        if (!thread) throw new Error("Provide either a threadID or a threadMediaID");

        if (!instance) instance = null;
        if (instance)
        {
          instance = await dbp.instances.create.one("en", instance.generatorID, null, instance.text0, instance.text1);
          instance = {
            _id: instance.instanceID,
            GeneratorID: instance.generatorID,
            DisplayName: instance.displayName,
            UrlName: instance.urlName,
            ImageID: instance.imageID,
            Text0: instance.text0,
            Text1: instance.text1,
          };
          instance._id = instance.instanceID;
        }

        const otherPosts = (await db.find("Posts", { ThreadID: thread._id }, { }, 1000, null, true));

        let post = {
          ThreadID: thread._id,
          Index: otherPosts.length,
          Text: text,
          ImageID: imageID,
          Attachment: {
            Media: media,
            Instance: instance,
          },
          Created: now,
        };

        post = await db.upsert("Posts", post, true);

        thread.postsCount = ((thread.postsCount || 0) + 1);
        thread.lastPostCreated = now;
        await db.upsert("Threads", thread);

        return post._id;
    Posts.delete.one:
      admin: true
      args: [postID]
      code: | #js
        const post = await db.findOne("Posts", { _id: postID });
        if (!post) return;
        const thread = await dbp.threads.select.one(post.threadID);
        await db.delete("Posts", { _id: postID });
        // Delete the thread if this is the first post
        if (post._id == thread.posts[0]._id)
        {
          await db.delete("Threads", { _id: thread._id });
          return;
        }
        thread.postsCount--;
        await db.upsert("Threads", thread);
    Comments.select.by:
      args: [entityID]
      code: | #js
        let comments = await db.find("Comments", { EntityType: 1, EntityID: entityID }, { }, 1000, null, true);
        comments = comments.sortBy(c => c._id);
        for (const comment of comments) comment.created = comment.created.valueOf();
        return comments;
