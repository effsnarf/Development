dom:
  ui.infinite.scroll:
    on_scroll: loadMore
    transition.group:
      tag: ul
      name: list
      ':class': gridClass
      li:
        v-for: (item, index) in items
        ':key': $root.getKey(item)
        component:
          ':is': itemType.kebabize()
          ':item': item
name: content-stream
props:
  itemType: null
  getMoreItems: null
  gridClass: null
data:
  pageIndex: 0
  items: []
  queue: []
  visibleItemIndex: null
mounted: |
  function() {
    this.processQueue();
    this.reset();
    document.addEventListener('scroll', this.onScroll.bind(this));
  }
methods:
  add: |
    function(item) {
      this.scrollTo(this.visibleItemIndex);
      this.items.insertAt(this.visibleItemIndex, item, true);
    }
  scrollTo: |
    function(index) {
      const items = this.$el.querySelectorAll('li');
      const item = items[index];
      if (!item) return;
      const rect = item.getBoundingClientRect();
      const topMargin = 250;
      const top = rect.top + window.scrollY - topMargin;
      window.scrollTo({ top, behavior: 'smooth' });
    }
  onScroll: |
    function() {
      this.updateVisibleItemIndex();
    }
  updateVisibleItemIndex: |
    function() {
      const items = this.$el.querySelectorAll('li');
      const visibleItemIndex = Array.from(items).findIndex(this.isOnScreen.bind(this));
      this.visibleItemIndex = visibleItemIndex;
    }
  isOnScreen: |
    function(item) {
      const rect = item.getBoundingClientRect();
      const viewHeight = Math.max(document.documentElement.clientHeight, window.innerHeight);
      return (rect.top > 0) && (rect.bottom < viewHeight);
    }
  reset: |
    async function() {
      this.pageIndex = 0;
      this.items = [];
      await this.loadMore();
    }
  loadMore: |
    function() {
      return new Promise((resolve, reject) => {
        if (!this.getMoreItems) return resolve();
        const pageIndex = this.pageIndex++;
        this.queue.push(async () => {
          let newItems = await this.getMoreItems(pageIndex);
          newItems = newItems.exceptBy(this.items, this.$root.getKey);
          this.items.push(...newItems);
          this.updateVisibleItemIndex();
          resolve();
        });
      });
    }
  processQueue: |
    async function() {
      const next = this.queue.shift();
      if (next) await next();
      setTimeout(this.processQueue.bind(this), 300);
    }
style:
  ul:
    display: grid
    gap: 5rem
template: >-
  <ui-infinite-scroll class="comp-content-stream"
  @scroll="loadMore"><transition-group tag="ul" name="list"
  :class="gridClass"><li v-for="(item, index) in items"
  :key="$root.getKey(item)"><component :is="itemType.kebabize()"
  :item="item"></component></li></transition-group></ui-infinite-scroll>
