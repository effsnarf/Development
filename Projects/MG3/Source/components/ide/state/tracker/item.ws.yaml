dom:
  div:
    ui.context.window:
      v-if: (item.type == 'm')
      :icon: getIcon(item.type)
      ":title": item.key
      template#2:
        v-slot: content
        pre:
          code:
            v-html: getMethodBodyColored(item.compName, item.key)
        ui.textarea:
          ":value": getMethodBody(item.compName, item.key)
    ui.context.window#2:
      v-if: showFieldContext(item)
      :visible: isHoveringOverValue
      :icon: $root.getIcon(item)
      :title: item.key
      item-type: ui-value-any
      :bind-props: "{ value: item.newValue }"
      :key: "uid+'-'+item.key"
    .grid:
      ":class": item.type
      @click: onItemClick(item)
      div#1:
        v-text: $root.getIcon(item)
      div#3:
        v-text: item.key
      .newValue:
        ui.value.preview:
          ":value": item.newValue
        @mouseenter: onHoverValue
        @mouseleave: onUnhoverValue
props:
  uid: null
  item: null
data:
  isHoveringOverValue: false
mounted: | #js
  function() {
    this.$root.$on("state-changed", this.onStateChanged.bind(this));
  }
methods:
  onHoverValue: | #js
    function() {
      this.isHoveringOverValue = true;
      this.$root.$emit("preview-state-item", this.item);
    }
  onUnhoverValue: | #js
    function() {
      this.isHoveringOverValue = false;
      this.$root.$emit("preview-state-item", null);
    }
  onItemClick: | #js
    function(item) {
      this.$root.$emit("watch-state-item", { uid: this.uid, key: item.key });
      console.log(item);
    }
  showFieldContext: | #js
    function(item) {
      if (item.type == "m") return false;
      if (typeof(item.newValue) == "boolean") return false;
      if ([undefined, null].includes(item.newValue)) return false;
      return true;
    }
  getMethodBodyColored: | #js
    function(compName, methodName) {
      let methodBody = this.getMethodBody(compName, methodName);
      methodBody = Prism.highlight(methodBody, Prism.languages.javascript, 'javascript');
      return methodBody;
    }
  getMethodBody: | #js
    function(compName, methodName) {
      const comp = this.$root.getComponent(compName);
      if (!comp) return null;
      const methodBody = comp.source.methods[methodName] || comp.source[methodName];
      if (!methodBody) return null;
      return methodBody;
    }
  onStateChanged: | #js
    function(item) {
      //if (item.key == this.item.key) this.refresh();
    }
watch:
style:
  .grid:
    grid-template: 1fr / 1.2em 5em 5em
    gap: 1em
    width: min-content
    text-wrap: nowrap
    overflow: hidden
  .grid > *:
    overflow: hidden
  .comp-name:
    opacity: 0.5
  .newValue:
    color: cyan
  .oldValue:
    opacity: 0.5
  .comp-ui-textarea:
    width: 40em
    height: 20em
    font-size: 110%
name: ide-state-tracker-item
template: >-
  <div class="comp-ide-state-tracker-item" path="841306122."><ui-context
  v-if="(item.type == 'm')" path="841306122.0"><template v-slot:title
  path="841306122.0.0"><div class="flex" path="841306122.0.0.0"><ui-title
  icon="ðŸ”´" :text="item.key" path="841306122.0.0.0.0"></ui-title><ui-checkbox
  text="pause" v-model="stateTracker.methods.pause[item.key]"
  path="841306122.0.0.0.1"></ui-checkbox></div></template><template
  v-slot:content path="841306122.0.1"><pre path="841306122.0.1.0"><code
  v-html="getMethodBodyColored(item.compName, item.key)"
  path="841306122.0.1.0.0"></code></pre><ui-textarea
  :value="getMethodBody(item.compName, item.key)"
  path="841306122.0.1.1"></ui-textarea></template></ui-context><div class="grid"
  :class="item.type" path="841306122.1"><ui-checkbox text="pause"
  v-model="stateTracker.methods.pause[item.key]"
  path="841306122.1.0"></ui-checkbox><div v-text="getIcon(item.type)"
  path="841306122.1.1"></div><div class="comp-name" v-text="item.compName"
  path="841306122.1.2"></div><div v-text="item.key"
  path="841306122.1.3"></div><div class="newValue"
  path="841306122.1.4"><ui-value-any :value="item.newValue"
  path="841306122.1.4.0"></ui-value-any></div></div></div>
