dom:
  div: 
    v-if: item
    div: 
      ':class': '{ sizeRef: true, clickable: editable }'
      ref: sizeRef1
      .text:
        ':class': getCssClass(item)
        ':style': itemStyle
        div: 
          v-html: $root.textToHtml(item.text)
          title: ✏️ edit
          @click: onClickText
        transition:
          name: slide
          ui.text.box:
            v-if: showEditor
            ':class': getCssClass(item)
            v-model: item.text
name: e-template-caption-item
props:
  item: null
  editable: false
data:
  width: null
  showEditor: false
mounted: | #js
  function () {
    window.addEventListener(`resize`, this.recalc.bind(this));
    // Detect if the image element changes its size
    let resizeObserver = new ResizeObserver(this.recalc.bind(this));
    resizeObserver.observe(this.$refs.sizeRef1);
  }
methods:
  onClickText: | #js
    function () {
      if (this.editable && this.item.editable)
      {
        this.showEditor = !this.showEditor;
        return;
      }
      this.$emit("click");
    }
  onLoad: | #js
    function () {
      this.recalc();
      [1,2,3].forEach(i => setTimeout(this.recalc.bind(this), i * 100))
    }
  recalc: | #js
    function () {
      if (!this.$refs.sizeRef1) return;
      let rect = this.$refs.sizeRef1.getBoundingClientRect();
      this.width = Math.round(rect.width);
      this.height = Math.round(rect.height);
      this.$emit("change");
    }
  getCssClass: | #js
    function(item) {
      const cls = {};
      cls[`h-${item.align.h}`] = true;
      cls[`v-${item.align.v}`] = true;
      return cls;
    }
  getStyle: | #js
    function(item) {
      const style = {};
      style.fontSize = this.getFontSize(item.text);
      style.fontFamily = item.font;
      if (item.uppercase) style.textTransform = "uppercase";
      style.color = item.color;
      const isDark = (item.color == "black");
      const outlineColor = (isDark ? "white" : "black");
      let outlineWidth = Math.max(1, Math.round(this.width/400));
      outlineWidth = `${(isDark ? outlineWidth : outlineWidth*2)}px`;
      style.textShadow = `-1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000`
        .replace(/1px/g, outlineWidth)
        .replace(/#000/g, outlineColor);
      return style;
    }
  getFontSize: | #js
    function (s) {
      if (!s) return 0;
      if (!this.width) return 0;
      let size = Math.min(3, Math.max(14, (36 - (s.length / 6))) / 50 *  this.width / 150);
      size = size * 2.5;
      if (this.item.scale) size *= this.item.scale;
      return `${size}vh`;
    }
computed:
  itemStyle: | #js
    function () {
      return this.getStyle(this.item);
    }
style:
  input[type="text"]:
    font-size: 100%
  .size-ref, .text:
    width: 100%
    object-fit: cover
    position: relative
    user-select: none
  .size-ref:
    height: fit-content
  .h-left:
    text-align: left
  .h-center:
    text-align: center
  .h-center input:
    text-align: center
  .h-right:
    text-align: right
  .v-top:
    top: 0
  .v-center:
    top: 50%
    transform: translateY(-50%)
  .v-bottom:
    bottom: 0
  .text:
    display: block
    overflow: hidden
    color: '#fff'
    line-height: 1.2em
    font-family: Impact,Oswald
    '-webkit-font-smoothing': antialiased
    box-sizing: border-box
    padding: 0.3em
    filter: 'drop-shadow(-2px 4px 2px #00000080)'
    transition: 0s
template: >-
  <div class="comp-e-template-caption-item" v-if="item" path="128142918."><div
  :class="{ sizeRef: true, clickable: editable }" ref="sizeRef1"
  path="128142918.0"><div class="text" :class="getCssClass(item)"
  :style="itemStyle" path="128142918.0.0"><div
  v-html="$root.textToHtml(item.text)" title="✏️ edit" @click="onClickText"
  path="128142918.0.0.0"></div><transition name="slide"
  path="128142918.0.0.1"><ui-text-box v-if="showEditor"
  :class="getCssClass(item)" v-model="item.text"
  path="128142918.0.0.1.0"></ui-text-box></transition></div></div></div>
