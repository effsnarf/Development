dom:
  div: null
props:
  input: null
  operation: null
data:
  isDirty: 0
  output: null
methods:
  evaluateOps: | #js
    function(input, operations) {
      if (!operations?.length) return input;
      let output = input;
      for (const operation of operations) {
        output = this.evaluate(output, operation);
      }
      return output;
    }
  evaluate: | #js
    function(input, operation) {
      if (!input) return null;
      if (!operation) return input;
      const method = this[`${operation.type}`.replace(/\./g, "_")];
      if (!method) throw new Error(`Method ${operation.type} not found`);
      const output = method(input, operation);
      return output;
    }
  select_fields: | #js
    function(input, op) {
      if (!op?.fields?.length) return input;
      if (Array.isArray(input)) {
        return input.map(item => Objects.getObjectFields(item, op?.fields));
      }
      if (typeof input == "object") {
        return Objects.getObjectFields(input, op?.fields);
      }
      return input;
    }
  select_path: | #js
    function(input, op) {
      if (!op?.path?.length) return input;
      return Objects.getProperty(input, op?.path.join("."));
    }
  flat_map: | #js
    function(input, op) {
      if (!Array.isArray(input)) return input;
      return input.flatMap(item => item);
    }
watch:
  output:
    handler: | #js
      function(output) {
        this.$emit("output", output);
      }
  input:
    handler: | #js
      function(input) {
        this.isDirty++;
      }
    immediate: true
  operation:
    handler: | #js
      function(operation) {
        this.isDirty++;
      }
    immediate: true
    deep: true
  isDirty:
    handler: | #js
      function() {
        this.output = this.evaluate(this.input, this.operation);
      }
_:
  examples:
    count: 0
name: ui-linq-evaluator
template: <div class="comp-ui-linq-evaluator"></div>
