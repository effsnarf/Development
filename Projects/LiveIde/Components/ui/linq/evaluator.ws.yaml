dom:
  div:
    ui.error:
      v-for: error in errors
      ':error': error
props:
  input: null
  operation: null
data:
  isDirty: 0
  output: null
  errors: []
methods:
  evaluateOps: | #js
    function(input, operations) {
      this.errors = [];
      const datas = [];
      datas.push(input);
      if (!operations?.length) return datas;
      for (const operation of operations) {
        try
        {
          const output = this.evaluate(datas.last(), operation);
          datas.push(output);
        }
        catch (ex)
        {
          datas.push(datas.last());
          this.errors.push(ex.message);
        }
      }
      return datas;
    }
  evaluate: | #js
    function(input, operation) {
      if (!input) return null;
      if (!operation) return input;
      const method = this[`${operation.type}`.replace(/\./g, "_")];
      if (!method) throw new Error(`Method ${operation.type} not found`);
      const output = method(input, operation);
      return output;
    }
  select_field: | #js
    function(input, op) {
      if (!op?.path?.length) return input;
      return Objects.getProperty(input, op?.path.join("."));
    }
  select_fields: | #js
    function(input, op) {
      if (!op?.fields?.length) return input;
      if (Array.isArray(input)) {
        return input.map(item => Objects.getObjectFields(item, op?.fields));
      }
      if (typeof input == "object") {
        return Objects.getObjectFields(input, op?.fields);
      }
      return input;
    }
  flat_map: | #js
    function(input, op) {
      if (!Array.isArray(input)) return input;
      const key1 = Object.keys(input[0])[0];
      return input.flatMap(item => item[key1]);
    }
  custom_expression: | #js
    function(input, op) {
      if (!op?.func) return input;
      const func = eval(op.func);
      return func(input);
    }
  no_op: | #js
    function(input, op) {
      return Objects.clone(input);
    }
watch:
  output:
    handler: | #js
      function(output) {
        this.$emit("output", output);
      }
  input:
    handler: | #js
      function(input) {
        this.isDirty++;
      }
    immediate: true
  operation:
    handler: | #js
      function(operation) {
        this.isDirty++;
      }
    immediate: true
    deep: true
  isDirty:
    handler: | #js
      function() {
        this.output = this.evaluate(this.input, this.operation);
      }
_:
  examples:
    count: 0
name: ui-linq-evaluator
template: >-
  <div class="comp-ui-linq-evaluator" path="-1130530213."><ui-error v-for="error
  in errors" :error="error" path="-1130530213.0"></ui-error></div>
