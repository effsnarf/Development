title: database.interface
server:
  host: localhost
  port: 5051
project:
  folder: (env) => env.path.resolve(env.process.cwd(), '../Source')
webscript:
  folder: (env) => env.path.join(env.process.cwd(), "../../../Shared/WebScript")
websiteHost:
  folder: (env) => env.path.resolve(env.process.cwd(), '../../WebsiteHost')
static:
  folder: (env) => env.process.cwd()
handler: | #js
  (ctx) => {
    return async (req, res, data) => {
      const cache = (global.cache = (global.cache || {}));
      // Get only the url path, without the query string.
      const url = req.url.split('?')[0];
      if (url == "/api/prompt/to/task") {
        const { entities, prompt } = data;
        const chat = await ctx.ChatOpenAI.new(ctx.Roles.ChatGPT, false);

        // First we need to find out the relevant entities
        let msg = `Which entities are relevant to this task?

        reply in this format:
        (don't write anything else, not even \`\`\` delimiters)

        [ "entity1", "entity2", ...]

        entities: ${JSON.stringify(entities.map(e => e.name), null, 2)}

        task: ${prompt}`;

        const relEntityNames = JSON.parse(await chat.send(msg));

        const relEntities = entities.filter(e => relEntityNames.includes(e.name));

        const relEntitiesShort = relEntities
          .map(e => (
          `${e.name}
          (${e.stats.count} items)
          ${e.fields.map(f => `${f.name} (${f.type})`).join(', ')}
          indexes: ${e.indexes.map(indx => `(${Object.entries(indx.key).map(([k, v]) => `${k}:${v}`).join(', ')})`).join(', ')}

          `
        ))
        .join('\n')
        .split('\n')
        .map(l => l.trim())
        .join('\n');


        msg = `
        I will ask you questions about my database and you'll help me find solutions.

        these are the relevant entities from the database we're working on:

        ${JSON.stringify(relEntitiesShort, null, 2)}}

        your query can only use fields that actually exist in the schema I provided.
        the query you're writing will be executed as eval(),
        so ensure that your query execution includes iterating over the cursor and fetching the results (toArray() etc)
        
        reply in this format:
        (don't write anything else, not even \`\`\` delimiters)
        (make sure the JSON is strictly and properly formatted)

        {
          "title": "...", (what info the user wants to know, formatted as a short question),
          "solutions": [ (suggest several ways to solve the problem)
            {
              "title": {
                "icon": "...", (query: 🔎, index: 📃, create: ➕, update: ✏️, delete: 🗑️, or other)
                "text": "...", (short, descriptive title, phrased as a command, example: "find all the people who were born in 1990")
              },
              "query": "...", (if can be done in a single query),
              "interesting": {
                "fields": ["...", "..."], (fields that are interesting to the user, for example, the name of the person, the date of birth, etc)
              },
            },
            ...
          ]
        }
        

        the task is:

        ${prompt}`;

        if (!cache[msg])
        {
          const result = JSON.parse(await chat.send(msg));
          cache[msg] = result;
        }

        const result = cache[msg];

        delete cache[msg];

        return res.end(JSON.stringify(result));
      }

    };
  }
