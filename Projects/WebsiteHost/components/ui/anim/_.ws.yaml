dom:
  div:
    ui.ticker:
      :interval: totalAnimDuration
      :count: 2
      @tick: nextAnimTick
      :enabled: autoPlayLoop
    ui.html.style:
      :component: "{ source: { style: animCssStyleObj } }"
    div:
      :class: listCls
      slot:

props:
  anim:
  duration: 1000
  stagger: 100
  itemsCount:
  autoPlayLoop: true

data:
  listCls: []

methods:
  init: | #js
    function() {
      this.nextAnimTick(null);
    }
  nextAnimTick: | #js
    async function(index) {
      const anim = this.anim;
      if (!anim) return;

      this.listCls.clear();
      this.listCls.push("list-anim");
      this.listCls.push(`list-anim-${anim.name}`);

      if (index == 0) {
        this.listCls.push("anim-leaving");
      }
      if (index == 1) {
        this.listCls.push("anim-entering");
        await this.$nextTick();
        await (0.1).seconds().wait();
        this.listCls.remove("anim-entering");
      }
    }
  getAnimCssStyleObj: | #js
    function(anim) {
      if (!anim) return null;
      const s = {};

      s[`.page-entering .list-anim-${anim.name} > .list-item`] = anim.enter.from;
      s[`.page-leaving .list-anim-${anim.name} > .list-item`] = anim.leave.to;
      s[`.list-anim-${anim.name}.anim-entering > .list-item`] = anim.enter.from;
      s[`.list-anim-${anim.name}.anim-leaving > .list-item`] = anim.leave.to;

      return s;
    }

computed:
  animCssStyleObj: | #js
    function() {
      return this.getAnimCssStyleObj(this.anim);
    }
  totalAnimDuration: | #js
    function() {
      return (this.duration + (this.itemsCount * this.stagger));
    }

watch:
  anim:
    immediate: true
    deep: false
    handler: | #js
      function(newAnim) {
        this.init();
      }