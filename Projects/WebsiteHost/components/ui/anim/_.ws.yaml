dom:
  div:
    ui.ticker:
      :interval: (duration1 * 2)
      :count: 2
      @tick: nextAnimTick
      :enabled: autoPlayLoop
    ui.html.style:
      :component: "{ source: { style: animCssStyleObj } }"
    div:
      :class: listCls
      :style: styleObj
      slot:

props:
  anim:
  animState: 
  duration: 1000
  itemIndex: 0
  itemsCount: 1
  autoPlayLoop: false

data:
  animStateFrame: null
  autoPlayAnimState: null

methods:
  init: | #js
    function() {
    }
  nextAnimTick: | #js
    async function(index) {
      const anim = this.anim;
      if (!anim) return;

      this.autoPlayAnimState = this.getNextAnimState(this.autoPlayAnimState);
    }
  getNextAnimState: | #js
    function(animState) {
      switch (animState) {
        case "entering":
          return "leaving";
        case "leaving":
          return "entering";
        default:
          return "entering";
      }
    }
  setAnimStateFrame: | #js
    async function(animState) {
      this.animStateFrame = animState;
      if (animState == "entering") {
        requestAnimationFrame(() => { this.animStateFrame = null; });
      }
    }
  getAnimCssStyleObj: | #js
    function(anim) {
      if (!anim) return null;
      const s = {};

      s[`.list-anim-${anim.name}`] = { transition: `${this.duration1}ms` };
      s[`.page-entering .list-anim-${anim.name}`] = anim.enter.from;
      s[`.page-leaving .list-anim-${anim.name}`] = anim.leave.to;
      const enterSelector = `.list-anim-${anim.name}.anim-entering`;
      const leaveSelector = `.list-anim-${anim.name}.anim-leaving`;
      s[enterSelector] = anim.enter.from;
      s[leaveSelector] = anim.leave.to;
      // when a page transitions, internal animations are triggered
      s[`.page > .comp-ui-anim > .anim-entering ${enterSelector}`] = anim.enter.from;
      s[`.page > .comp-ui-anim > .anim-leaving ${leaveSelector}`] = anim.leave.to;

      // list items transition delay
      // const td = [];
      // const staggers = Array(this.itemsCount).fill(0).map((_, i) => i * this.stagger).reverse();
      // // staggers array has [0, stagger, stagger*2, stagger*3, ...]
      // for (let i = 0; i < this.itemsCount; i++) {
      //   td.push({
      //     sel: `.list-items-${this.itemsCount} > *:nth-child(${i+1})`,
      //     val: { 'transition-delay': `${staggers.pop()}ms` }}
      //   );
      // }
      // for (const t of td) s[t.sel] = t.val;

      return s;
    }
  getStyleObj: | #js
    function() {
      const s = {};
      if (this.itemIndex) s['transition-delay'] = `${this.itemIndex * this.stagger}ms`;
      return s;
    }

computed:
  listCls: | #js
    function() {
      if (!this.anim) return [];

      const listCls = [];
      listCls.push("list-anim");
      listCls.push(`list-anim-${this.anim.name}`);

      if (this.animStateFrame) listCls.push(`anim-${this.animStateFrame}`);

      return listCls;
    }
  animCssStyleObj: | #js
    function() {
      return this.getAnimCssStyleObj(this.anim);
    }
  duration1: | #js
    function() {
      return (this.duration || 1000);
    }
  stagger: | #js
    function() {
      return Math.round(this.duration1 / this.itemsCount);
    }
  styleObj: | #js
    function() {
      return this.getStyleObj();
    }

watch:
  anim:
    immediate: true
    deep: false
    handler: | #js
      function(newAnim) {
        this.init();
      }
  animState:
    immediate: true
    handler: | #js
      function(newAnimState) {
        this.setAnimStateFrame(newAnimState);
      }
  autoPlayLoop: | #js
    function(apl) {
      // when stopping auto-play, we set frame 0
      if (!apl) this.nextAnimTick(0);
    }
  autoPlayAnimState:
    immediate: true
    handler: | #js
      function(newAnimState) {
        if (this.autoPlayLoop) this.setAnimStateFrame(newAnimState);
      }

style:
  .list-anim:
    overflow: hidden